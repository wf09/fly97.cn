<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人随想</title>
  
  
  <link href="https://www.fly97.cn/atom.xml" rel="self"/>
  
  <link href="https://www.fly97.cn/"/>
  <updated>2021-05-07T02:00:00.000Z</updated>
  <id>https://www.fly97.cn/</id>
  
  <author>
    <name>个人随想</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python3中decode和encode的区别</title>
    <link href="https://www.fly97.cn/p/how-to-use-requests-in-python/"/>
    <id>https://www.fly97.cn/p/how-to-use-requests-in-python/</id>
    <published>2021-05-07T02:00:00.000Z</published>
    <updated>2021-05-07T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>聊聊Python3中decode和encode的区别</p><a id="more"></a><h3 id="decode和encode的区别">decode和encode的区别</h3><p>字符串编码常用类型：utf-8,gb2312,cp936,gbk等。</p><p>Python3中，取消了unicode类型，代替它的是使用unicode字符的字符串类型(str)，字符串类型(str)成为了基础类型，编码后的类型成为了字节类型(bytes)</p><p>​ decode encode</p><p>bytes--------------&gt;str------------&gt;bytes</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="string">&#x27;中文&#x27;</span>                 <span class="comment">#指定字符串类型对象u</span></span><br><span class="line">s = u.encode(<span class="string">&#x27;gb2312&#x27;</span>)     <span class="comment">#以gb2312编码对u进行编码, 获得bytes类型对象s</span></span><br><span class="line">u1 = s.decode(<span class="string">&#x27;gb2312&#x27;</span>)    <span class="comment">#以gb2312编码对s进行解码, 获得str类型对象u</span></span><br><span class="line">u2 = s.decode(<span class="string">&#x27;utf-8&#x27;</span>)     <span class="comment">#以utf-8编码对s进行解码, 将无法获得还原原来的字符串内容</span></span><br></pre></td></tr></table></figure><h3 id="section"></h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;聊聊Python3中decode和encode的区别&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://www.fly97.cn/tags/Python/"/>
    
    <category term="decode" scheme="https://www.fly97.cn/tags/decode/"/>
    
    <category term="encode" scheme="https://www.fly97.cn/tags/encode/"/>
    
  </entry>
  
  <entry>
    <title>Python3中的正则表达式</title>
    <link href="https://www.fly97.cn/p/how-to-use-re-in-python/"/>
    <id>https://www.fly97.cn/p/how-to-use-re-in-python/</id>
    <published>2021-05-07T02:00:00.000Z</published>
    <updated>2021-05-07T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：这个模块提供了正则表达式匹配操作。模式和被搜索的字符串既可以是unicode字符串(str类型)，也可以是8位字节串。但是两者不能混用。当进行替换操作时，替换字符串的类型也必须与所用的模式和搜索的字符串类型一致。</p><p>关键字：Python，正则表达式</p><a id="more"></a><p>正则表达式使用反斜杠字符来表示特殊形式或是允许在使用特殊字符时不引发他们的特殊含义。例如，要匹配一个反斜杠字面值，用户可能必须写成 <code>'\\\\'</code> 来作为模式字符串，因为正则表达式必须为 <code>\\</code>，而每个反斜杠在普通 Python 字符串字面值中又必须表示为 <code>\\</code>。</p><p>解决办法时对于正则表达式样式使用Python的原始字符串表达法；在带有<code>'r'</code>前缀的字符串字面值中，反斜杠不必做任何特殊处理。</p><p>因此<code>r''\n</code>表示包含<code>\</code>和<code>n</code>的两个字符的字符串，而""则表示只包含一个换行符的字符串。样式在Python代码中通常都会使用这种原始字符串表示法来表示。</p><p>绝大多数正则表达式操作都提供模块函数和方法，在编译正则表达式这些函数是一个途径，不需要先编译一个正则对象，但是损失了一些优化参数。</p><h3 id="正则表达式语法">正则表达式语法</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：这个模块提供了正则表达式匹配操作。模式和被搜索的字符串既可以是unicode字符串(str类型)，也可以是8位字节串。但是两者不能混用。当进行替换操作时，替换字符串的类型也必须与所用的模式和搜索的字符串类型一致。&lt;/p&gt;
&lt;p&gt;关键字：Python，正则表达式&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://www.fly97.cn/tags/Python/"/>
    
    <category term="re" scheme="https://www.fly97.cn/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>Python3 requests如何定制header</title>
    <link href="https://www.fly97.cn/p/how-to-customize-headers-for-python-requests/"/>
    <id>https://www.fly97.cn/p/how-to-customize-headers-for-python-requests/</id>
    <published>2021-05-06T05:32:00.000Z</published>
    <updated>2021-05-06T05:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>聊聊Python的request库</p><a id="more"></a><h3 id="定制请求头">定制请求头</h3><p>如果想为请求添加HTTP头部，只需要简单传递一个<code>dict</code>给<code>headers</code>参数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line">import requests</span><br><span class="line">url &#x3D; &quot;&quot;</span><br><span class="line">payload &#x3D; &#123;&#39;some&#39;:&#39;data&#39;&#125;</span><br><span class="line">headers &#x3D; &#123;&#39;content-type&#39;:&#39;application&#x2F;json&#39;&#125;</span><br><span class="line">r &#x3D; requests.post(url, data&#x3D;json.dumps(payload), headers&#x3D;headers)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;聊聊Python的request库&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://www.fly97.cn/tags/Python/"/>
    
    <category term="requests" scheme="https://www.fly97.cn/tags/requests/"/>
    
  </entry>
  
  <entry>
    <title>Python装饰器abstractmethod</title>
    <link href="https://www.fly97.cn/p/how-to-use-python-abstractmethod/"/>
    <id>https://www.fly97.cn/p/how-to-use-python-abstractmethod/</id>
    <published>2021-05-05T07:45:00.000Z</published>
    <updated>2021-05-05T07:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用Python装饰器abstractmethod实现纯虚函数</p><a id="more"></a><p><code>@abstractmethod</code>用于程序接口的控制，含有<code>@abstractmethod</code>修饰的父类不能被实例化，且继承的子类必须实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadTools</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upload</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_urls</span>(<span class="params">self</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpyunTools</span>(<span class="params">UploadTools</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I am upyuntools.&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upload</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I am upload method in UpyunTools.&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I am delete method in UpyunTools.&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I am delete method in UpyunTools&quot;</span>)</span><br><span class="line">    <span class="comment"># def get_urls(self) -&gt; str:</span></span><br><span class="line">    <span class="comment">#     print(&quot;I am get_urls method in UpyunTools.&quot;)</span></span><br><span class="line">    <span class="comment">#     return None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    upyun_tools = UpyunTools()</span><br><span class="line">    upyun_tools.upload()</span><br><span class="line">    upyun_tools.get_urls()</span><br><span class="line">    upyun_tools.delete()</span><br></pre></td></tr></table></figure><p>将子类get_urls方法注释后无法运行：</p><figure><img src="C:\Users\0xFF\AppData\Roaming\Typora\typora-user-images\image-20210505170431677.png" alt="image-20210505170431677" /><figcaption>image-20210505170431677</figcaption></figure><p>将子类的<code>get_urls</code>方法修改后可以运行：</p><figure><img src="C:\Users\0xFF\AppData\Roaming\Typora\typora-user-images\image-20210505170513260.png" alt="image-20210505170513260" /><figcaption>image-20210505170513260</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用Python装饰器abstractmethod实现纯虚函数&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://www.fly97.cn/tags/Python/"/>
    
    <category term="abstractmethod" scheme="https://www.fly97.cn/tags/abstractmethod/"/>
    
  </entry>
  
  <entry>
    <title>理解Python</title>
    <link href="https://www.fly97.cn/p/how-to-use-python-abstractmethod/"/>
    <id>https://www.fly97.cn/p/how-to-use-python-abstractmethod/</id>
    <published>2021-05-05T07:45:00.000Z</published>
    <updated>2021-05-05T07:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>聊聊Python的装饰器</p><a id="more"></a><p>谈装饰器之前，首先要明白一件事，Python中的函数和Java，C++不太一样，Python中的函数可以通过普通变量一样当作参数传入另一个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">print(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">func</span>):</span></span><br><span class="line">func()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">bar(foo)</span><br></pre></td></tr></table></figure><p>装饰器本质上是一个Pythob函数或者类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。他经常用于有切面需求的场景，比如：插入日志，性能测试，事务处理，缓存，权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器继续重用。</p><p>一句话，<strong>装饰器就是为已经存在的对象添加额外的功能</strong>。</p><p>一个简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">print(<span class="string">&#x27;i am foo&#x27;</span>)</span><br></pre></td></tr></table></figure><p>现在有一个新需求，希望可以记录下函数的执行日志，于是在函数中添加日志代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">print(<span class="string">&#x27;i am foo&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;foo is runing&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果函数bar()，bar()也有类似的需求，怎么做？再写一个logging日志在bar函数里？这样就造成了大量雷同代码，为了减少业务量，我们需要重新定义一个新的函数，专门处理日志，日志处理完再执行真正的业务代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span>(<span class="params">func</span>):</span></span><br><span class="line">logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">func()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">print(<span class="string">&#x27;i am foo&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;main&#x27;</span>:</span><br><span class="line">    use_logging(foo)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;聊聊Python的装饰器&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://www.fly97.cn/tags/Python/"/>
    
    <category term="abstractmethod" scheme="https://www.fly97.cn/tags/abstractmethod/"/>
    
  </entry>
  
  <entry>
    <title>零基础入门ROS(三)</title>
    <link href="https://www.fly97.cn/p/ros-tutorial-03/"/>
    <id>https://www.fly97.cn/p/ros-tutorial-03/</id>
    <published>2021-04-26T11:48:00.000Z</published>
    <updated>2021-04-26T11:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近的小车需要用到ROS，学习的过程做个记录。</p><p>今天写的主要是使用opencv进行相机标定（Camera Calibration）的步骤。</p><a id="more"></a><h3 id="下载opencv源码">下载opencv源码</h3><p>这里用到的源码版本是opencv3.2.0，操作环境是Ubuntu 18.04 LTS。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/opencv/opencv/archive/refs/tags/3.2.0.tar.gz</span><br><span class="line">tar -xvf 3.2.0.tar.gz</span><br></pre></td></tr></table></figure><h3 id="使用已有的图片进行标定">使用已有的图片进行标定</h3><h4 id="编译camera_calibration.cpp">编译camera_calibration.cpp</h4><h5 id="进入指定目录">进入指定目录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd opencv-3.2.0</span><br><span class="line">cd samples&#x2F;cpp&#x2F;tutorial_code&#x2F;calib3d&#x2F;camera_calibration</span><br></pre></td></tr></table></figure><h5 id="创建cmakelist.txt文件">创建CMakeList.txt文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim CMakeLists.txt</span><br></pre></td></tr></table></figure><p>复制下列代码到文件.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">find_package</span>( OpenCV REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"><span class="keyword">add_executable</span>( camera_calibration camera_calibration.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( camera_calibration <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure><h5 id="编译">编译</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build </span><br><span class="line">cd build </span><br><span class="line">cmake ..</span><br><span class="line">make </span><br></pre></td></tr></table></figure><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/calibration01.png" /></p><h5 id="修改参数">修改参数</h5><p>编辑同级目录下的<code>in_VID5.xml</code>文件，根据标定靶的行数和列数来修改参数。这里的使用的标定靶一共有<strong>6</strong>行，每一行有8个内部角点。</p><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/calibration02.png" /></p><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/calibration03.png" /></p><p>其中<code>VID5.xml</code>存放的是标定图片路径，一般图片应不少于3张，图片越多标定效果越好。</p><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/calibration04.png" /></p><h5 id="标定">标定</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv build&#x2F;camera_calibration .</span><br><span class="line">.&#x2F;camera_calibration .&#x2F;in_VID5.xml</span><br></pre></td></tr></table></figure><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/calibration05.png" /></p><p>生成的out_camera_data.xml就是标定后得到的参数文件。</p><h3 id="使用视频对摄像头进行标定">使用视频对摄像头进行标定</h3><h4 id="编译calibration.cpp">编译calibration.cpp</h4><h5 id="进入指定目录-1">进入指定目录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd opencv-3.4.3</span><br><span class="line">mkdir -p ..&#x2F;calibration_ws</span><br><span class="line">cp samples&#x2F;cpp&#x2F;calibration.cpp ..&#x2F;calibration_ws</span><br><span class="line">cd ..&#x2F;calibration_ws</span><br></pre></td></tr></table></figure><h5 id="创建cmakelists.txt文件">创建CMakeLists.txt文件</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">find_package</span>( OpenCV REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"><span class="keyword">add_executable</span>( calibration calibration.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( calibration <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure><h5 id="编译-1">编译</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make </span><br></pre></td></tr></table></figure><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/calibration06.png" /></p><h5 id="标定-1">标定</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x calibration</span><br><span class="line">.&#x2F;calibration -w&#x3D;8 -h&#x3D;6</span><br></pre></td></tr></table></figure><p>这里的h指的是标定靶一共有<strong>6</strong>行，w指的是每一行有<strong>8</strong>个内部角点。</p><p>按g键开始标定。</p><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/calibration07.png" /></p><p>标定完毕。</p><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/calibration08.png" /></p><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/calibration09.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近的小车需要用到ROS，学习的过程做个记录。&lt;/p&gt;
&lt;p&gt;今天写的主要是使用opencv进行相机标定（Camera Calibration）的步骤。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ROS" scheme="https://www.fly97.cn/tags/ROS/"/>
    
    <category term="camera calibration" scheme="https://www.fly97.cn/tags/camera-calibration/"/>
    
  </entry>
  
  <entry>
    <title>零基础入门ROS(二)</title>
    <link href="https://www.fly97.cn/p/ros-tutorial-02/"/>
    <id>https://www.fly97.cn/p/ros-tutorial-02/</id>
    <published>2021-04-26T11:48:00.000Z</published>
    <updated>2021-04-26T11:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近的小车需要用到ROS，学习的过程做个记录。</p><a id="more"></a><h3 id="ros中的工作空间">ROS中的工作空间</h3><h4 id="工作空间是什么">工作空间是什么</h4><p>工作空间是一个存放工程相关开发文件的文件夹，ROS默认使用的是catkin编译系统。</p><p>典型的工作空间包含以下四个目录空间：</p><ol type="1"><li><code>src</code>：代码空间，开发过程中最常用的文件夹。用来存放所有ROS功能包的源码文件。</li><li><code>build</code>：编译空间，用来存储工作空间编译过程中产生缓存信息和中间文件。</li><li><code>devel</code>：开发空间，用来放置编译生成的可执行文件。</li><li><code>install</code>：安装空间，编译成功后，可以使用<code>make install</code>命令将可执行文件安装到该空间中，运行该空间中的环境变量脚本，即可以在终端中运行这些可执行文件。注意：安装空间在工作空间中不是必须的，很多工作空间中没有该文件夹。</li></ol><h4 id="创建工作空间">创建工作空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><h4 id="编译工作空间">编译工作空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h4 id="设置环境变量">设置环境变量</h4><p>编译完成后<code>devel</code>文件夹下会生成<code>setup.bash</code>形式的环境变量设置脚本，使用<code>source</code>命令运行这些脚本文件，则工作空间的环境变量可以生效。</p><p>注意：每一次编译完成后都要运行一次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure><p>运行以下命令查看环境变量是否生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure><p>若生效则会显示出当前工作空间的路径。</p><h4 id="创建功能包">创建功能包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg subsciber rospy std_msgs geometry_msgs</span><br></pre></td></tr></table></figure><p>其中<code>subsciber</code>是包名，剩下的是功能包所需要的依赖。</p><p>创建完成后，需要<strong>编译工作空间</strong>，并且<strong>设置环境变量</strong>。</p><h4 id="查看功能包所在的工作空间">查看功能包所在的工作空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rospack find subsciber</span><br></pre></td></tr></table></figure><h3 id="话题和服务">话题和服务</h3><h4 id="话题">话题</h4><p>消息以一种发布/订阅的方式传递。一个节点可以订阅多个话题，一个话题也可以被多个节点订阅。两个节点通信时，启动顺序没有强制要求，且<strong>实时性</strong>较弱，不适用于双向的同步传输。</p><h4 id="服务">服务</h4><p>服务是一种带有应答的通信机制。ROS只允许有一个节点提供指定命名的服务。实时性较强，适用于两个节点之间的同步传输。</p><table><thead><tr class="header"><th></th><th>话题</th><th>服务</th></tr></thead><tbody><tr class="odd"><td>同步性</td><td>异步</td><td>同步</td></tr><tr class="even"><td>通信模型</td><td>发布/订阅</td><td>客户端/服务端</td></tr><tr class="odd"><td>底层协议</td><td>ROSTCP/ROSUDP</td><td>ROSTCP/ROSUDP</td></tr><tr class="even"><td>反馈机制</td><td>无</td><td>有</td></tr><tr class="odd"><td>缓冲区</td><td>有</td><td>无</td></tr><tr class="even"><td>实时性</td><td>弱</td><td>强</td></tr><tr class="odd"><td>节点关系</td><td>多对多</td><td>一对多（一个server）</td></tr><tr class="even"><td>适用场景</td><td>数据传输</td><td>逻辑处理</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近的小车需要用到ROS，学习的过程做个记录。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ROS" scheme="https://www.fly97.cn/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>零基础入门ROS(一)</title>
    <link href="https://www.fly97.cn/p/ros-tutorial-01/"/>
    <id>https://www.fly97.cn/p/ros-tutorial-01/</id>
    <published>2021-04-25T11:29:00.000Z</published>
    <updated>2021-04-25T11:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近的小车需要用到ROS，学习的过程做个记录。</p><p>此次记录的主要是软件安装过程中遇到的问题。</p><a id="more"></a><h3 id="ubuntu1804-换源">ubuntu1804 换源</h3><p>安装好Ubuntu 1804以后首先换源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install apt-transport-https ca-certificates -y</span><br><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sed -i <span class="string">&quot;s/cn.archive.ubuntu.com/mirrors.aliyun.com/g&quot;</span> /etc/apt/sources.list</span><br><span class="line">sed -i <span class="string">&quot;s/http/https/g&quot;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>其中，安装<code>apt-transport-https</code>并将安装协议更换到<code>https</code>以避免运营商缓存劫持。</p><h3 id="安装ros-melodic">安装ROS Melodic</h3><p>参考 <a href="http://wiki.ros.org/cn/melodic/Installation/Ubuntu">http://wiki.ros.org/cn/melodic/Installation/Ubuntu</a></p><h4 id="设置sources.list">设置sources.list</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;deb https://mirrors.aliyun.com/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="更新">【更新】</h5><p>国科大ROS源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;deb https://mirrors.ustc.edu.cn/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure><p>北外ROS源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;deb https://mirrors.bfsu.edu.cn/ros/ubuntu/ $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="设置密钥">设置密钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure><p>另一种方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL <span class="string">&#x27;http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654&#x27;</span> | sudo apt-key add -</span><br></pre></td></tr></table></figure><h4 id="安装">安装</h4><p>桌面完整版：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install ros-melodic-desktop-full -y</span><br></pre></td></tr></table></figure><h3 id="初始化rosdep">初始化rosdep</h3><p>初始化需要使用代理服务器，设置代理服务器后请修改<code>sudo</code>配置文件以传递环境变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><h3 id="设置环境">设置环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source &#x2F;opt&#x2F;ros&#x2F;melodic&#x2F;setup.bash&quot; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><h3 id="构建工厂依赖">构建工厂依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近的小车需要用到ROS，学习的过程做个记录。&lt;/p&gt;
&lt;p&gt;此次记录的主要是软件安装过程中遇到的问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ROS" scheme="https://www.fly97.cn/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Python多线程的应用</title>
    <link href="https://www.fly97.cn/p/how-to-use-python-multithreading/"/>
    <id>https://www.fly97.cn/p/how-to-use-python-multithreading/</id>
    <published>2021-04-02T10:45:00.000Z</published>
    <updated>2021-04-02T10:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>创建线程之前，需要首先了解一下进程和线程的区别，父线程和子线程的区别：</p><ul><li>每个进程至少有一个线程，作为程序的入口，这个线程就是主线程。</li><li>每个进程至少有一个主线程，其他线程成为工作线程。</li><li>父线程：如果线程A启动了一个线程B，A就是B的父线程。</li><li>子线程：B就是A的子线程。</li></ul><a id="more"></a><h4 id="使用threading.thread模块创建线程">使用threading.Thread模块创建线程</h4><p>Python3通过threading包提供对线程的支持。</p><h5 id="简单使用">简单使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>(<span class="params">delay_s, time_loop</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(time_loop):</span><br><span class="line">        time.sleep(delay_s)</span><br><span class="line">        print(<span class="string">f&quot;The delay is <span class="subst">&#123;delay_s&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threading.Thread(target=say_hello, args=[<span class="number">2</span>, <span class="number">2</span>]).start()</span><br><span class="line">threading.Thread(target=say_hello, args=[<span class="number">1</span>, <span class="number">1</span>]).start()</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/threading01.png" /></p><p>程序运行到12行时，启动子线程1执行say_hello(2, 2)，此时主线程继续向下执行；</p><p>程序运行到13行时，启动子线程2执行say_hello(1, 1)，此次主线程执行完毕，等待子线程执行完毕。</p><p>1秒后子线程2先执行完毕，切换到另一个子线程1继续执行。</p><h5 id="daemon属性的设置">daemon属性的设置</h5><p>Python中，在构造线程对象时，可以设置<code>daemon</code>属性，这个属性必须在start方法前设置好。</p><p>主线程是程序启动第一个线程，主线程可以在启动<code>n</code>个子线程。</p><p>daemon属性可以不设置，默认为<code>None</code>，主线程默认是<code>False</code>。</p><p>daemon属性分为以下三种：</p><h6 id="daemonfalse">daemon=False</h6><p>当<code>daemon</code>属性为<code>False</code>时，父线程在运行完毕时，会等待所有子线程退出才结束程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>(<span class="params">delay_s=<span class="number">1</span>, time_loop=<span class="number">3</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(time_loop):</span><br><span class="line">        print(<span class="string">f&quot;i = <span class="subst">&#123;i&#125;</span>, say_hello daemon is <span class="subst">&#123;threading.current_thread().isDaemon()&#125;</span>&quot;</span>)</span><br><span class="line">        time.sleep(delay_s)</span><br><span class="line"></span><br><span class="line">threading.Thread(target=say_hello).start()</span><br><span class="line">print(<span class="string">f&quot;Main thread daemon is <span class="subst">&#123;threading.current_thread().isDaemon()&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;Main thread daemon Exit.&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/threading02.png" /></p><p>通过<code>isDaemon()</code>方法可以返回当前线程的<code>daemon</code>值，主线程默认是<code>False</code>，子线程也是<code>False</code>的原因是创建线程对象时指定了<code>daemon=False</code>.</p><p>主程序在构造线程对象时就立即启动了，然后子线程返回了结果中的第一行内容，然后sleep(1)模拟IO，此时CPU发现子线程阻塞了，马上切换到主线程继续执行，主线程先后打印第二行和第三行，此时主线程的代码已经执行到结尾。</p><p>因为主线程为子线程的<code>daemon</code>值设置为<code>False</code>，这时就又发生了线程切换到子线程，子线程先后执行完第四行和第五行，然后子线程就全部执行完毕，主线程看到子线程退出后，也立即退出，整个程序结束。</p><h6 id="daemontrue">daemon=True</h6><p>当<code>daemon</code>为<code>True</code>时，父线程在执行完毕后，无论子线程是否正在运行，都会伴随父进程一起退出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>(<span class="params">delay_s=<span class="number">1</span>, time_loop=<span class="number">3</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(time_loop):</span><br><span class="line">        print(<span class="string">f&quot;i = <span class="subst">&#123;i&#125;</span>, say_hello daemon is <span class="subst">&#123;threading.current_thread().isDaemon()&#125;</span>&quot;</span>)</span><br><span class="line">        time.sleep(delay_s)</span><br><span class="line"></span><br><span class="line">threading.Thread(target=say_hello, daemon=<span class="literal">True</span>).start()</span><br><span class="line">print(<span class="string">f&quot;Main thread daemon is <span class="subst">&#123;threading.current_thread().isDaemon()&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;Main thread daemon Exit.&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/threading03.png" /></p><p>当daemon设置为True时，即主线程不关心子线程状态，主线程退出，子线程也必须跟着退出。</p><p>运行结果中子线程就执行了一行语句，此时CPU发现子线程阻塞，线程切换到主线程，主线程执行完最后两句，就立即退出，整个程序结束。</p><h6 id="daemonnone">daemon=None</h6><p>daemon属性可以不设置，默认值是None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_grandson_thread</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">f&quot;say_grandson_thread daemon is <span class="subst">&#123;threading.current_thread().isDaemon()&#125;</span>\n&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_son_thread</span>(<span class="params">time_loop=<span class="number">3</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(time_loop):</span><br><span class="line">        print(<span class="string">f&quot;i = <span class="subst">&#123;i&#125;</span>, say_son_thread daemon is <span class="subst">&#123;threading.current_thread().isDaemon()&#125;</span>\n&quot;</span>)</span><br><span class="line">        threading.Thread(target=say_grandson_thread, daemon=<span class="literal">None</span>).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threading.Thread(target=say_son_thread, daemon=<span class="literal">True</span>).start()</span><br><span class="line">print(<span class="string">f&quot;Main thread daemon is <span class="subst">&#123;threading.current_thread().isDaemon()&#125;</span>&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">&quot;Main thread daemon Exit.&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/threading04.png" /></p><p>这里在主线程中使用了延迟1秒，来让子线程启动的子线程有机会输出其daemon属性值，如果不设置延迟，还没等到子线程的子线程启动，子线程就结束了，最终导致子线程的子线程无法启动。</p><p><img src="https://ftp.fly97.cn/images/fly97.cn/20210426/threading05.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;创建线程之前，需要首先了解一下进程和线程的区别，父线程和子线程的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个进程至少有一个线程，作为程序的入口，这个线程就是主线程。&lt;/li&gt;
&lt;li&gt;每个进程至少有一个主线程，其他线程成为工作线程。&lt;/li&gt;
&lt;li&gt;父线程：如果线程A启动了一个线程B，A就是B的父线程。&lt;/li&gt;
&lt;li&gt;子线程：B就是A的子线程。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://www.fly97.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>安装Chromium浏览器并解决缺少 Google API 密钥问题</title>
    <link href="https://www.fly97.cn/p/how-to-install-Chromium-and-solve-the-problem/"/>
    <id>https://www.fly97.cn/p/how-to-install-Chromium-and-solve-the-problem/</id>
    <published>2021-02-09T10:49:00.000Z</published>
    <updated>2021-02-09T10:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Chromium</strong>是<a href="https://zh.wikipedia.org/wiki/Google">Google</a>为发展浏览器<a href="https://zh.wikipedia.org/wiki/Google_Chrome">Google Chrome</a>而开启的免费开源软件项目。Chromium的用户界面极简。Google期望使浏览器“在认知和物理上都让人感觉轻巧，快速”。（英语：feel lightweight (cognitively and physically) and fast.</p><p>本文主要介绍如何下载Chromium浏览器并解决缺少 Google API 密钥问题。</p><p><strong>关键词：Chromium缺少 Google API</strong></p><a id="more"></a><h4 id="下载chromium">下载Chromium</h4><p>官方站点：https://download-chromium.appspot.com/</p><p>分发站点：<a href="https://chromium.woolyss.com/#updater">Download latest stable Chromium binaries (64-bit and 32-bit) (woolyss.com)</a></p><p><img src="https://fly97.coding.net/p/images/d/github/git/raw/master/20210209/get_chromium.png" /></p><p>解压后放置到任意文件夹。</p><p><img src="https://fly97.coding.net/p/images/d/github/git/raw/master/20210209/unzip_chromium.png" /></p><h4 id="关闭缺少-google-api-密钥提示">关闭缺少 Google API 密钥提示</h4><p>首次打开Chromium时，地址栏下方会提示 <strong>缺少 Google API 密钥，因此 Chromium 的部分功能将无法使用</strong>。</p><p>法一：如不需要登录谷歌账户，仅仅想屏蔽上述烦人的提示，可以直接设置<strong>相关环境变量为<code>no</code></strong>，屏蔽提示。</p><p>打开 windows 的 <code>cmd</code> 命令提示符，依次输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setx GOOGLE_API_KEY <span class="string">&quot;no&quot;</span></span><br><span class="line">setx GOOGLE_DEFAULT_CLIENT_ID <span class="string">&quot;no&quot;</span></span><br><span class="line">setx GOOGLE_DEFAULT_CLIENT_SECRET <span class="string">&quot;no&quot;</span></span><br></pre></td></tr></table></figure><p>法二：加入Chromuim-Dev谷歌群组并开启相关API</p><p>搬运自：http://www.chromium.org/developers/how-tos/api-keys</p><ol type="1"><li><p>加入Google Groups <a href="https://groups.google.com/a/chromium.org/forum/?fromgroups#!forum/chromium-dev">chromium-dev@chromium.org</a>，如果介意相关邮件打扰可以选择退订相关邮件。为方便起见，以下API仅限对订加入社群的人可见</p></li><li><p>确保登陆了已经订阅chromium-dev社群的Google账号</p></li><li><p>打开 https://cloud.google.com/console</p></li><li><p>创建或使用现有项目 <img src="https://fly97.coding.net/p/images/d/github/git/raw/master/20210209/open_a_gcp_project.png" /></p></li><li><p>选择 <code>API和服务-&gt;库</code>，搜索下图给出的API，并按需启用相关API</p><p><img src="https://fly97.coding.net/p/images/d/github/git/raw/master/20210209/open_api_1.png" /></p></li></ol><figure><img src="https://fly97.coding.net/p/images/d/github/git/raw/master/20210209/open_api_2.png" alt="API库" /><figcaption>API库</figcaption></figure><figure><img src="https://fly97.coding.net/p/images/d/github/git/raw/master/20210209/oepn_api_3.png" alt="启用同步API" /><figcaption>启用同步API</figcaption></figure><ol start="5" type="1"><li>返回上级菜单，选择<code>凭据-&gt;创建凭据-&gt;OAuth客户端ID</code>，应用类型选择<code>桌面应用</code>，名称<code>任选</code>。记录得到的客户端ID和客户端密钥。 <img src="https://fly97.coding.net/p/images/d/github/git/raw/master/20210209/make_oauth_id_1.png" alt="创建凭据" /></li></ol><p><img src="https://fly97.coding.net/p/images/d/github/git/raw/master/20210209/make_oauth_id_2.png" /></p><p><img src="https://fly97.coding.net/p/images/d/github/git/raw/master/20210209/make_oauth_id_3.png" /></p><ol start="6" type="1"><li>返回上级菜单，选择<code>凭据-&gt;创建凭据-&gt;API密钥</code>，名称<code>任选</code>。</li></ol><p><img src="https://fly97.coding.net/p/images/d/github/git/raw/master/20210209/create_api_key.png" /></p><h5 id="设置环境变量">设置环境变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOOGLE_API_KEY&#x3D;your_api_key</span><br><span class="line">GOOGLE_DEFAULT_CLIENT_ID&#x3D;your_client_id</span><br><span class="line">GOOGLE_DEFAULT_CLIENT_SECRET&#x3D;your_client_secret</span><br></pre></td></tr></table></figure><p>完.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Chromium&lt;/strong&gt;是&lt;a href=&quot;https://zh.wikipedia.org/wiki/Google&quot;&gt;Google&lt;/a&gt;为发展浏览器&lt;a href=&quot;https://zh.wikipedia.org/wiki/Google_Chrome&quot;&gt;Google Chrome&lt;/a&gt;而开启的免费开源软件项目。Chromium的用户界面极简。Google期望使浏览器“在认知和物理上都让人感觉轻巧，快速”。（英语：feel lightweight (cognitively and physically) and fast.&lt;/p&gt;
&lt;p&gt;本文主要介绍如何下载Chromium浏览器并解决缺少 Google API 密钥问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词：Chromium缺少 Google API&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Chromium" scheme="https://www.fly97.cn/tags/Chromium/"/>
    
  </entry>
  
  <entry>
    <title>selenium常用方法</title>
    <link href="https://www.fly97.cn/p/Selenium-positioning-method/"/>
    <id>https://www.fly97.cn/p/Selenium-positioning-method/</id>
    <published>2021-02-08T12:53:00.000Z</published>
    <updated>2021-02-08T12:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Selenium 是一个综合性的项目，为web浏览器的自动化提供了各种工具和依赖包。本文主要介绍的是 selenium的常用方法。</p><p><strong>关键词：Selenium常用方法</strong></p><a id="more"></a><h3 id="模拟手机访问">模拟手机访问</h3><p>一般情况下，手机端页面更简单，容易提取元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;mobileEmulation&#x27;</span>, mobile_emulation)</span><br></pre></td></tr></table></figure><h3 id="设置chrome为无头模式">设置chrome为无头模式</h3><p>在 Chrome 59　中开始搭载 <a href="https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md">Headless Chrome</a>。这是一种在无需显示<em>headless</em>的环境下运行 Chrome 浏览器的方式。从本质上来说，就是不用打卡Chrome窗口来运行 Chrome 的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="加载网址">加载网址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome.get(&quot;http:&#x2F;&#x2F;stu.zstu.edu.cn&quot;)</span><br></pre></td></tr></table></figure><h3 id="定位元素">定位元素</h3><h4 id="id定位">id定位</h4><p>HTML 规定id 属性在HTML 文档中必须是唯一的。这类似于公民的身份证号，具有很强的唯一性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome.find_element_by_id(&quot;app&quot;)</span><br></pre></td></tr></table></figure><h4 id="name定位">name定位</h4><p>HTML 规定name 来指定元素的名称，因此它的作用更像是人的姓名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome.find_element_by_name(&quot;name&quot;)</span><br></pre></td></tr></table></figure><h4 id="class定位">class定位</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome.find_element_by_class(&quot;classname&quot;)</span><br></pre></td></tr></table></figure><h4 id="tag定位">tag定位</h4><p>HTML 的本质就是通过tag来定义实现不同的功能，每一个元素本质上也是一个tag.</p><p>因为一个tag 往往用来定义一类功能，所以通过tag识别某个元素的概率很低.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome.find_element_by_tag_name(&quot;tagname&quot;)</span><br></pre></td></tr></table></figure><h4 id="link-text-定位"><strong>link text 定位</strong></h4><p>find_element_by_link_text()方法通过元素标签对之间的文本信息来定位元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome.find_element_by_link_text(&quot;text&quot;)</span><br></pre></td></tr></table></figure><h4 id="partial-link-定位"><strong>partial link 定位</strong></h4><p>partial link 定位是对link 定位的一种补充，有些文本链接会比较长，这个时候可以取文本链接的一部分定位，只要这一部分信息可以唯一地标识这个链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome.find_element_by_partial_link_text(&quot;partial text&quot;)</span><br></pre></td></tr></table></figure><h4 id="xpath定位">XPATH定位</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome.find_element_by_xpath(&quot;&quot;)</span><br></pre></td></tr></table></figure><p>XPath是XML的路径语言，通俗一点讲就是通过元素的路径来查找到这个标签元素</p><h5 id="定位页面下所有元素">定位页面下所有元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;*[@id&#x3D;&quot;app&quot;]&#x2F;div</span><br></pre></td></tr></table></figure><h5 id="绝对路径定位">绝对路径定位</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;html&#x2F;body&#x2F;div&#x2F;div</span><br></pre></td></tr></table></figure><h5 id="利用元素属性定位">利用元素属性定位</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#x2F;&#x2F;input[@placeholder&#x3D;&#39;请通过XPATH定位元素&#39;]&quot;</span><br></pre></td></tr></table></figure><h5 id="利用标签所含文字进行定位">利用标签所含文字进行定位</h5><p>严格匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;div[text()&#x3D;&quot;健康申报&quot;]</span><br></pre></td></tr></table></figure><p>部分匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;div[contains(text(), &quot;健康申报&quot;)]</span><br></pre></td></tr></table></figure><h5 id="层级与属性相结合">层级与属性相结合</h5><p>当标签页重复时，Xpath提供了层级过滤。</p><p>例如，找不到儿子，那么就先找他的爸爸，或者找他的爷爷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;&#x2F;&#x2F;label[contains(text(), &quot;文本内容&quot;)]&#x2F;..&#x2F;following-sibling::div[1]&#x2F;&#x2F;input&#39;</span><br></pre></td></tr></table></figure><p><code>..</code> 表示当前节点的父节点</p><p><code>following-sibling::div[1]</code> 表示当前节点的<strong>兄弟节点</strong>中的 <strong>第 1 个</strong> <strong>div</strong>标签</p><h5 id="使用逻辑运算符">使用逻辑运算符</h5><p>如果一个属性不能唯一的区分一个元素，可以使用逻辑运算符连接多个属性来查找元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;select[@name&#x3D;&#39;city&#39; and @size&#x3D;&#39;4&#39; and @multiple&#x3D;&quot;multiple&quot;]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Selenium 是一个综合性的项目，为web浏览器的自动化提供了各种工具和依赖包。本文主要介绍的是 selenium的常用方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词：Selenium常用方法&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://www.fly97.cn/tags/Python/"/>
    
    <category term="Selenium" scheme="https://www.fly97.cn/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>crontab定时任务不执行</title>
    <link href="https://www.fly97.cn/p/crontab-does-not-work/"/>
    <id>https://www.fly97.cn/p/crontab-does-not-work/</id>
    <published>2021-02-06T02:41:00.000Z</published>
    <updated>2021-02-06T02:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在生产环境下，添加了 crontab 定时计划任务，后面发现，定时任务并没有执行，在指定的文件夹下并没有相对应的日志产生。</p><p><strong>关键词：crontab定时计划任务不执行</strong></p><a id="more"></a><h4 id="查看crontab服务状态">查看crontab服务状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serivice cron status</span><br></pre></td></tr></table></figure><p>其中若出现 <code>(CRON) info (No MTA installed, discarding output)</code>字样，说明linux系统中没有安装<code>postfix</code>。Postfix 是一种电子邮件服务器软件。当crontab执行脚本时，会将输出通过本地的文本邮件的方式传递给当前用户，传递的内容存放在<code>/var/mail/&lt;当前用户名&gt;</code>文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install postfix -y</span><br></pre></td></tr></table></figure><h4 id="将标准错误和标准输出重定向到文件">将标准错误和标准输出重定向到文件</h4><p>当所有的输出重定向到文件以后，crontab就不会给本地用户发信息啦，也就解决了上节的问题。</p><p><strong>为了将所有的输出</strong>都重定向到文件，可以在cron里写 <code>*/1 * * * * r.sh</code></p><p><code>r.sh</code>里写 <code>a.sh &gt;&gt; /root/a.log 2&gt;&amp;1</code></p><h5 id="附录linux重定向">附录：linux重定向</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; filename 　　　　　把标准输出重定向到一个新文件中</span><br><span class="line"><span class="built_in">command</span> &gt;&gt; filename 　　　　　把标准输出重定向到一个文件中(追加)</span><br><span class="line"><span class="built_in">command</span> 1 &gt; fielname 　　　　　把标准输出重定向到一个文件中</span><br><span class="line"><span class="built_in">command</span> &gt; filename 2&gt;&amp;1 　　　把标准输出和标准错误一起重定向到一个文件中</span><br><span class="line"><span class="built_in">command</span> 2 &gt; filename 　　　　把标准错误重定向到一个文件中</span><br><span class="line"><span class="built_in">command</span> 2 &gt;&gt; filename 　　　　把标准输出重定向到一个文件中(追加)</span><br><span class="line"><span class="built_in">command</span> &gt;&gt; filename 2&gt;&amp;1 　　把标准输出和标准错误一起重定向到一个文件中(追加)</span><br><span class="line"><span class="built_in">command</span> &lt; filename &gt;filename2 　　把<span class="built_in">command</span>命令以filename文件作为标准输入，以filename2文件作为标准输出</span><br><span class="line"><span class="built_in">command</span> &lt; filename 　　　把<span class="built_in">command</span>命令以filename文件作为标准输入</span><br><span class="line"><span class="built_in">command</span> &lt;&lt; delimiter 　　把从标准输入中读入，直至遇到delimiter分界符</span><br><span class="line"><span class="built_in">command</span> &lt;&amp;m 　　　把文件描述符m作为标准输入</span><br><span class="line"><span class="built_in">command</span> &gt;&amp;m 　　　把标准输出重定向到文件描述符m中</span><br><span class="line"><span class="built_in">command</span> &lt;&amp;- 　　　把关闭标准输入 </span><br></pre></td></tr></table></figure><p><strong>&gt; 默认为标准输出重定向，与 1&gt; 相同 2&gt;&amp;1</strong> 意思是把 标准错误输出 重定向到 标准输出.</p><p><strong>&amp;&gt;file</strong> 意思是把<strong>标准输出</strong> 和 <strong>标准错误输出</strong> 都重定向到文件file中</p><p><strong>/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在生产环境下，添加了 crontab 定时计划任务，后面发现，定时任务并没有执行，在指定的文件夹下并没有相对应的日志产生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词：crontab定时计划任务不执行&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="crontab" scheme="https://www.fly97.cn/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5教程</title>
    <link href="https://www.fly97.cn/p/PyQt5-Chinese-tutorial/"/>
    <id>https://www.fly97.cn/p/PyQt5-Chinese-tutorial/</id>
    <published>2021-02-02T06:31:00.000Z</published>
    <updated>2021-02-02T06:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习PyQt的基本功能。</p><a id="more"></a><h3 id="例1-简单的窗口">例1 简单的窗口</h3><p>这个简单的小例子展示的是一个小窗口。但是我们可以在这个小窗口上面很多事情，改变大小，最大化，最小化等。这需要很多代码能实现。这在很多应用中很常见，没必要每次都要重写这一部分代码，Qt已经提供了这些功能。PyQt5是一个高级的工具集合，相比使用低级的工具，能省略上百行代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    </span><br><span class="line">    w = QWidget()</span><br><span class="line">    w.resize(<span class="number">250</span>, <span class="number">150</span>)</span><br><span class="line">    w.move(<span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line">    w.setWindowTitle(<span class="string">&#x27;Simple&#x27;</span>)</span><br><span class="line">    w.show()</span><br><span class="line">    </span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>运行上面的代码，能展示出一个小窗口。</p><p>分步讲解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget</span><br></pre></td></tr></table></figure><p>这里引入了PyQt5.QtWidgets这个模块，这个模块包含了基本的组件。</p><hr /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app &#x3D; QApplication(sys.argv)</span><br></pre></td></tr></table></figure><p>每个PyQt5应用都必须创建这样的一个应用对象。sys.argv是一组命令行参数的列表。<strong>Python可以在shell里运行，这个参数提供了对脚本控制的功能。</strong></p><hr /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w &#x3D; QWidget()</span><br></pre></td></tr></table></figure><p>QWidget控件是一个用户界面的<strong>基本控件</strong>，它提供了基本的应用构造器。默认情况下，构造器是没有父级的，<strong>没有父级的构造器被称为窗口(window)。</strong></p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.resize(<span class="number">250</span>, <span class="number">150</span>)</span><br></pre></td></tr></table></figure><p>resize()方法能改变控件的大小，这里的意思是窗口宽250px，高150px.</p><hr /><p>move()是修改控件位置的方法，它把控件放置到屏幕坐标的(300, 300)的位置。<strong>屏幕坐标系的原点是屏幕的左上角。</strong></p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.setWindowTitle(<span class="string">&#x27;Simple&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们给这个窗口添加了一个标题，标题在标题栏展示。<strong>虽然这看起来是一句废话，但是后面还有各种栏，还是要重点说一下。</strong></p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.show()</span><br></pre></td></tr></table></figure><p>show()能让控件在桌面上显示出来。控件在内存里创建，调用这个函数才能在操作系统上显示出来。</p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>最后，我们进入了应用的主循环中，事件处理器这个时候开始工作。主循环从窗口上接收事件，并把事件派发到应用控件里。当调用<code>exit()</code>方法或直接销毁主控件时，主循环就会结束。<code>sys.exit()</code>方法能确保主循环安全退出。外部环境会收到主控件如何结束的信息。</p><p><code>exec_()</code>之所以有个下划线，是因为<code>exec</code>是Python的一个关键字。</p><p>程序预览：</p><p><img src="https://fly97.coding.net/p/images/d/fly97.cn/git/raw/master/20210202/qt5_01.png" /></p><h3 id="例2-带窗口图标">例2 带窗口图标</h3><p>窗口图标通常是显示一个窗口的左上角，标题栏的最左边。下面的例子就是怎么用PyQt5创建一个这样的窗口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.initUI()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.setGeometry(<span class="number">300</span>, <span class="number">300</span>, <span class="number">300</span>, <span class="number">220</span>)</span><br><span class="line">        self.setWindowTitle(<span class="string">&#x27;Icon&#x27;</span>)</span><br><span class="line">        self.setWindowIcon(Qicon(<span class="string">&#x27;web.png&#x27;</span>))</span><br><span class="line">        </span><br><span class="line">        self.show()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>此处用到了Python面向对象编程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span>(<span class="params">QWidget</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">super().__init__()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>面向对象编程最重要的三个部分是类(class)、数据和方法。<code>class Example:</code>创建了一个类的调用，这个类继承自<code>QWidget</code>类。调用了两个构造器，一个是这个类本身的，一个是这个类继承的。super()构造器方法返回父级的对象。<code>_\_init__()</code>方法是构造器的一个方法。</p><hr /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.initUI()</span><br></pre></td></tr></table></figure><p>使用<code>initUI()</code>方法创建一个GUI。</p><hr /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 自己准备一个web.png</span><br><span class="line">self.setGeometry(300, 300, 300, 220)</span><br><span class="line">self.setWindowTitle(&#39;Icon&#39;)</span><br><span class="line">self.setWindowIcon(QIcon(&#39;web.png&#39;))</span><br></pre></td></tr></table></figure><p>上面的三个方法都继承自<code>QWidget</code>类。<code>setGeometry()</code>有三个作用：把窗口放到屏幕上并设置窗口大小。参数分别代表屏幕坐标的x、y和窗口大小的宽、高。也就是说这个方法是<code>resize()</code>和<code>move()</code>的合体。最后一个方法是添加了图标。也创建了一个<code>QIcon</code>对象，然后接受一个路径作为参数显示图标。</p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(ex.exec_())</span><br></pre></td></tr></table></figure><p><img src="https://fly97.coding.net/p/images/d/fly97.cn/git/raw/master/20210202/qt5_02.png" /></p><h3 id="例3-提示框">例3 提示框</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QWidget, QToolTip, QPushButton, QApplication)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QFont</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.initUI()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span>(<span class="params">self</span>):</span></span><br><span class="line">        QToolTip.setFont(QFont(<span class="string">&#x27;SansSerif&#x27;</span>, <span class="number">10</span>))</span><br><span class="line">        </span><br><span class="line">        self.setToolTip(<span class="string">&#x27;This is a &lt;b&gt;QWidget&lt;/b&gt; widget&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        btn = QPushButton(<span class="string">&#x27;Button&#x27;</span>, self)</span><br><span class="line">        btn.setToolTip(<span class="string">&#x27;This is a &lt;b&gt;QPushButton&lt;/b&gt; widget&#x27;</span>)</span><br><span class="line">        btn.resize(btn.sizeHint())</span><br><span class="line">        btn.move(<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">        self.setGeometry(<span class="number">300</span>, <span class="number">300</span>, <span class="number">300</span>, <span class="number">200</span>)</span><br><span class="line">        self.setWindowTitle(<span class="string">&#x27;Tooltips&#x27;</span>)</span><br><span class="line">        self.show()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>在这个例子中, 我们为应用创建了一个提示框.</p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QToolTip.setFont(QFont(<span class="string">&#x27;SansSerif&#x27;</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>这个静态方法设置了提示框的字体。</p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.setToolTip(<span class="string">&#x27;This is a &lt;b&gt;QWidget&lt;/b&gt; wighet&#x27;</span>)</span><br></pre></td></tr></table></figure><p>调用<code>setToolTip()</code>创建提示框可以使用<strong>富文本格式</strong>的内容。</p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btn = QPushButton(<span class="string">&#x27;Button&#x27;</span>, self)</span><br><span class="line">btn.setToolTip(<span class="string">&#x27;This is a &lt;b&gt;QPushButton&lt;/b&gt; widget&#x27;</span>)</span><br></pre></td></tr></table></figure><p>创建一个按钮，并且为按钮添加了一个提示框。</p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btn.resize(btn.sizeHint())</span><br><span class="line">btn.move(<span class="number">50</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>调整按钮大小, 并且让按钮在屏幕上显示出来，sizeHint()方法提供了一个默认的按钮大小。</p><hr /><p><img src="https://fly97.coding.net/p/images/d/fly97.cn/git/raw/master/20210202/qt5_03.png" /></p><h3 id="例4-关闭窗口">例4 关闭窗口</h3><p>关闭窗口最直观的方式就是点击标题栏的叉叉，在这个例子里，我们展示的是如何用程序关闭一个窗口。这里我们将接触到一点<strong>信号(signal)和槽(slots)</strong>的知识。</p><p>本例使用的是<code>QPushButton</code>组件类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton(string text, QWidget parent &#x3D; None)</span><br></pre></td></tr></table></figure><p>text参数是想要显示的按钮名称，parent参数是放在按钮上的组件，在我们的例子里，这个参数是QWidget。应用中的组件都是经过一层层的继承来的。在这个层里，大部分的组件都有自己的父级，没有父级的组件被称为<strong>顶级窗口</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QWidget, QPushButton, QApplication</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QCoreApplication</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span>(<span class="params">QWidget</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">        self.initUI()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        qbtn = QPushButton(<span class="string">&#x27;Quit&#x27;</span>, self)</span><br><span class="line">        qbtn.clicked.connect(QCoreApplication.instance().quit)</span><br><span class="line">        qbtn.resize(qbtn.sizeHint())</span><br><span class="line">        qbtn.move(<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">        self.setGeometry(<span class="number">300</span>, <span class="number">300</span>, <span class="number">500</span>, <span class="number">250</span>)</span><br><span class="line">        self.setWindowTitle(<span class="string">&#x27;Quit button&#x27;</span>)</span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>上述代码创建了一个点击之后就推出窗口的按钮。</p><hr /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from PyQt5.QtCore import QCoreApplication</span><br></pre></td></tr></table></figure><p>程序需要<code>QtCore</code>对象。</p><hr /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qbtn &#x3D; QPushButton(&#39;Quit&#39;, self)</span><br></pre></td></tr></table></figure><p>创建一个<code>QPushButton</code>按钮。第一个参数是按钮的文本，第二个参数是按钮的父级组件，这个例子中，父级组件就是我们创建的继承自<code>QWidget</code>的<code>Example</code>类。</p><hr /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qbtn.clicked.connect(QCoreApplication.instance().quit)</span><br></pre></td></tr></table></figure><p>创建了<strong>信号(singal)和槽(slot)</strong>的连接。点击按钮之后，信号会被捕捉并给出既定的反应。<code>QCoreApplication</code>包含了时间的主循环，它能添加和删除所有的事件。<code>instance()</code>创建了一个它的实例。<code>QCoreApplication</code>是在<code>QApplication</code>里创建的。点击事件和能终止进程并推出应用的quit函数绑定在了一起。在发送者和接收者之间建立了通讯，发送者就是按钮，接收者就是应用对象。</p><figure><img src="https://fly97.coding.net/p/images/d/fly97.cn/git/raw/master/20210202/qt5_04.png" alt="image-20210226150310118" /><figcaption>image-20210226150310118</figcaption></figure><p>点击一下<code>Quit</code>，程序就会自动退出。</p><h3 id="例5-消息盒子">例5 消息盒子</h3><p>默认情况下，我们点击标题栏的x按钮，QWidget就会关闭。但是有时候，我们需要修改这个默认行为。例如，我们打开的是一个文件编辑器，并且做了一些修改，这个时候就需要在关闭按钮的时候让用户进一步确认操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QWidget, QMessageBox, QApplication</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        </span><br><span class="line">        self.initUI()</span><br><span class="line">        </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">initUI</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.setGeometry(<span class="number">300</span>, <span class="number">300</span>, <span class="number">250</span>, <span class="number">150</span>)</span><br><span class="line">        self.setWidnowTitle(<span class="string">&#x27;Message box&#x27;</span>)</span><br><span class="line">        self.show()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span>(<span class="params">self, event</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">       </span><br><span class="line">    reply = QMessageBox.question(self, <span class="string">&#x27;Message&#x27;</span>, <span class="string">&quot;Are you sure to quit?&quot;</span>, QMessageBox.Yes | QMessageBox.No, QMessageBox.No)</span><br><span class="line">        <span class="keyword">if</span> reply == QMessageBox.Yes:</span><br><span class="line">            event.accept()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            event.ignore()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>如果关闭<code>QWidget</code>，就会产生一个<code>QCloseEvent</code>，并且把它传入到<code>closeEvent</code>函数的event参数中。改变控件的默认行为，就是替换掉默认的事件处理。</p><hr /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reply &#x3D; QMessageBox.question(self, &#39;Message&#39;,&quot;Are you sure to quit?&quot;, QMessageBox.Yes | QMessageBox.No, QMessageBox.No)</span><br></pre></td></tr></table></figure><p>上述代码创建了一个消息框，上面有两个按钮：<code>Yes</code>和<code>No</code>。第一个字符串显示在消息框的标题，第二个字符串显示在对话框，第三个参数是消息框的两个按钮，最后一个参数是默认按钮，这个按钮是默选中的。返回值在变量<code>reply</code>里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> reply == QMessageBox.Yes:</span><br><span class="line">event.accept()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">event.ignore()</span><br></pre></td></tr></table></figure><p>这里判断返回值，如果点击的是Yes按钮，就关闭组件和应用，否则就忽略关闭事件。</p><p>程序预览：</p><p><img src="https://fly97.coding.net/p/images/d/fly97.cn/git/raw/master/20210202/qt5_05.png" /></p><p>例6 窗口居中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QWidget, QDestopWidget, QApplication</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span>(<span class="params">QWidget</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.initUI()</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">initUI</span>(<span class="params">self</span>):</span></span><br><span class="line">        </span><br><span class="line">        self.resize(<span class="number">250</span>, <span class="number">150</span>)</span><br><span class="line">        self.center()</span><br><span class="line">        </span><br><span class="line">        self.setWindowTitle(<span class="string">&#x27;Center&#x27;</span>)</span><br><span class="line">        self.show()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center</span>(<span class="params">self</span>):</span></span><br><span class="line">        qr = self.frameGeometry()</span><br><span class="line">        cp = QDesktopWidget().availableGeometry().center()</span><br><span class="line">        qr.moveCenter(cp)</span><br><span class="line">        self.move(qr.topLeft())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    </span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><hr /><p><code>QtGui.QDesktopWidget</code>提供了用户的桌面信息，包括屏幕的大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.center()</span><br></pre></td></tr></table></figure><p>这个方法调用下面实现对话框居中的方法。</p><hr /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qr &#x3D; self.frameGeometry()</span><br></pre></td></tr></table></figure><p>获得主窗口所在的框架。</p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp = QDesktopWidget().availableGeometry().center()</span><br></pre></td></tr></table></figure><p>获得显示器的分辨率，然后得到屏幕中心点的位置。</p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qr.moveCenter(cp)</span><br></pre></td></tr></table></figure><p>然后把主窗口框架中心点位置放置到屏幕的中心位置。</p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.move(qr.topLeft())</span><br></pre></td></tr></table></figure><p>然后通过move函数把主窗口的左上角移动到其框架的左上角，这样就把窗口居中了。</p><p>程序预览：</p><p><img src="https://fly97.coding.net/p/images/d/fly97.cn/git/raw/master/20210202/qt5_06.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习PyQt的基本功能。&lt;/p&gt;</summary>
    
    
    
    
    <category term="PyQt5" scheme="https://www.fly97.cn/tags/PyQt5/"/>
    
  </entry>
  
  <entry>
    <title>杭州旅游攻略</title>
    <link href="https://www.fly97.cn/p/Travel-in-Hangzhou/"/>
    <id>https://www.fly97.cn/p/Travel-in-Hangzhou/</id>
    <published>2021-01-31T06:31:00.000Z</published>
    <updated>2021-01-31T06:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>学在杭州，玩在杭州！</p><a id="more"></a><h3 id="延安路商业街">延安路商业街</h3><figure><img src="https://ftp.fly97.cn/image/image-20210131092627579.png" alt="image-20210131092627579" /><figcaption>image-20210131092627579</figcaption></figure><h3 id="延安路到法喜寺">延安路到法喜寺</h3><figure><img src="https://ftp.fly97.cn/image/image-20210131093545985.png" alt="image-20210131093545985" /><figcaption>image-20210131093545985</figcaption></figure><p>法喜寺</p><figure><img src="https://ftp.fly97.cn/image/image-20210131092418794.png" alt="image-20210131092418794" /><figcaption>image-20210131092418794</figcaption></figure><h3 id="延安路到河坊街">延安路到河坊街</h3><figure><img src="https://ftp.fly97.cn/image/image-20210131093828915.png" alt="image-20210131093828915" /><figcaption>image-20210131093828915</figcaption></figure><p>河坊街</p><figure><img src="https://ftp.fly97.cn/image/image-20210131092531902.png" alt="image-20210131092531902" /><figcaption>image-20210131092531902</figcaption></figure><h3 id="延安路到北高峰">延安路到北高峰</h3><p><img src="https://ftp.fly97.cn/image/image-20210131093705860.png" /></p><p>延安路</p><figure><img src="https://ftp.fly97.cn/image/image-20210131092737922.png" alt="image-20210131092737922" /><figcaption>image-20210131092737922</figcaption></figure><h3 id="西湖龙井">西湖龙井</h3><figure><img src="https://ftp.fly97.cn/image/image-20210131094030362.png" alt="image-20210131094030362" /><figcaption>image-20210131094030362</figcaption></figure><figure><img src="https://ftp.fly97.cn/image/image-20210131092947998.png" alt="image-20210131092947998" /><figcaption>image-20210131092947998</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;学在杭州，玩在杭州！&lt;/p&gt;</summary>
    
    
    
    
    <category term="Travel" scheme="https://www.fly97.cn/tags/Travel/"/>
    
    <category term="Hangzhou" scheme="https://www.fly97.cn/tags/Hangzhou/"/>
    
  </entry>
  
  <entry>
    <title>使用Zerotier搭建内网穿透服务</title>
    <link href="https://www.fly97.cn/p/how-to-use-Zerotier/"/>
    <id>https://www.fly97.cn/p/how-to-use-Zerotier/</id>
    <published>2021-01-28T06:31:00.000Z</published>
    <updated>2021-01-28T06:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是Zerotier？</p><p>ZeroTier将整个世界转变为单个数据中心或云区域。像将所有设备，虚拟机和应用程序都插入同一交换机一样，将它们联网。</p><p>本文主要介绍如何使用Zerotier搭建内网穿透服务。</p><a id="more"></a><p>有两种连接方式，一种是创建自己管理的虚拟局域网，一种是加入别人已经建立的虚拟局域网。这里先说第一种。</p><h4 id="创建账号">创建账号</h4><p>https://www.zerotier.com/，点击<code>Sign up</code>.</p><p><img src="https://ftp.fly97.cn/image/image-20210128181221059.png" /></p><p>根据自己需要，选择注册方式。</p><p><img src="https://ftp.fly97.cn/image/image-20210128181326421.png" /></p><h4 id="创建网络">创建网络</h4><p><img src="https://ftp.fly97.cn/image/image-20210128181610919.png" /></p><p>点击 <code>Create A Network</code>，创建自己管理的虚拟局域网。</p><p><img src="https://ftp.fly97.cn/image/image-20210128181706204.png" /></p><p>创建成功以后会得到<code>Network ID</code>。点击网络ID，进入管理界面。</p><p><img src="https://ftp.fly97.cn/image/image-20210128181808319.png" /></p><p>此时虚拟局域网内还没有设备，需要终端加入该网络。</p><h4 id="加入网络">加入网络</h4><p><img src="https://ftp.fly97.cn/image/image-20210128181920181.png" /></p><p>点击<code>Download</code>，进入下载页面。</p><p><img src="https://ftp.fly97.cn/image/image-20210128181957790.png" /></p><p>根据自己的设备类型选择安装包。这里以Windows为例。</p><p><img src="https://ftp.fly97.cn/image/image-20210128182051328.png" alt="image-20210128182051328" style="zoom:50%;" /></p><p>等待下载完成，然后安装。</p><p><img src="https://ftp.fly97.cn/image/image-20210128182357823.png" alt="image-20210128182357823" style="zoom:50%;" /></p><p>打开以后会默认在任务栏运行。</p><figure><img src="https://ftp.fly97.cn/image/image-20210128182448852.png" alt="image-20210128182448852" /><figcaption>image-20210128182448852</figcaption></figure><p>右键选择<code>Join a network</code>。</p><p><img src="https://ftp.fly97.cn/image/image-20210128182523631.png" alt="image-20210128182523631" style="zoom:50%;" /></p><p>输入先前生成的网络ID，点击<code>Join</code>。其他选择默认设置即可。</p><p><img src="https://ftp.fly97.cn/image/image-20210128182553099.png" alt="image-20210128182553099" style="zoom: 67%;" /></p><p>稍后片刻，返回到管理页面，允许自己的电脑加入该网络，即✔对应的设备。</p><p><img src="https://ftp.fly97.cn/image/image-20210128182844550.png" /></p><p>得到虚拟网络的ip地址，之后再将另一个设备加入，就可以愉快的链接啦。</p><p><img src="https://ftp.fly97.cn/image/image-20210128183032664.png" /></p><h4 id="未完待续....">未完待续....</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是Zerotier？&lt;/p&gt;
&lt;p&gt;ZeroTier将整个世界转变为单个数据中心或云区域。像将所有设备，虚拟机和应用程序都插入同一交换机一样，将它们联网。&lt;/p&gt;
&lt;p&gt;本文主要介绍如何使用Zerotier搭建内网穿透服务。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Zerotier" scheme="https://www.fly97.cn/tags/Zerotier/"/>
    
  </entry>
  
  <entry>
    <title>记MT7621平台刷入OpenWRT</title>
    <link href="https://www.fly97.cn/p/how-to-config-OpenWRT/"/>
    <id>https://www.fly97.cn/p/how-to-config-OpenWRT/</id>
    <published>2021-01-23T06:31:00.000Z</published>
    <updated>2021-01-23T06:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是OpenWRT？</p><a id="more"></a><hr /><h3 id="安装luci相关">安装luci相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg install luci luci-base luci-i18n-base-zh-cn</span><br></pre></td></tr></table></figure><h3 id="开启sftp">开启sftp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install vsftpd openssh-sftp-server</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;vsftpd enable</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;vsftpd start</span><br></pre></td></tr></table></figure><h3 id="opkg-腾讯源">opkg 腾讯源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;opkg&#x2F;distfeeds.conf</span><br></pre></td></tr></table></figure><p>写入以下文字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">src&#x2F;gz openwrt_core https:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;openwrt&#x2F;releases&#x2F;19.07.2&#x2F;targets&#x2F;ramips&#x2F;mt7621&#x2F;packages</span><br><span class="line">src&#x2F;gz openwrt_base https:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;openwrt&#x2F;releases&#x2F;19.07.2&#x2F;packages&#x2F;mipsel_24kc&#x2F;base</span><br><span class="line">src&#x2F;gz openwrt_packages  https:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;openwrt&#x2F;releases&#x2F;19.07.2&#x2F;packages&#x2F;mipsel_24kc&#x2F;packages</span><br><span class="line">src&#x2F;gz openwrt_luci https:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;openwrt&#x2F;releases&#x2F;19.07.2&#x2F;packages&#x2F;mipsel_24kc&#x2F;luci</span><br><span class="line">src&#x2F;gz openwrt_routing https:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;openwrt&#x2F;releases&#x2F;19.07.2&#x2F;packages&#x2F;mipsel_24kc&#x2F;routing</span><br><span class="line">src&#x2F;gz openwrt_freifunk https:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;openwrt&#x2F;releases&#x2F;19.07.2&#x2F;packages&#x2F;mipsel_24kc&#x2F;freifunk</span><br><span class="line">src&#x2F;gz openwrt_telephony https:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;openwrt&#x2F;releases&#x2F;19.07.2&#x2F;packages&#x2F;mipsel_24kc&#x2F;telephony</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="luci禁用缓存">luci禁用缓存</h3><p>编辑/etc/config/luci</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config internal &#39;ccache&#39;</span><br><span class="line">        option enable &#39;0&#39;</span><br></pre></td></tr></table></figure><p>重启即可</p><h3 id="扩容root分区">扩容root分区</h3><p>安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg update &amp;&amp; opkg install block-mount kmod-fs-ext4 kmod-usb-storage kmod-usb-ohci kmod-usb-uhci e2fsprogs fdisk</span><br></pre></td></tr></table></figure><p>查看sd卡信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block info</span><br></pre></td></tr></table></figure><p>有类似回显，其中<code>/dev/mmcblk0p1</code>就是sd卡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dev&#x2F;mtdblock5: UUID&#x3D;&quot;d1f1302b-91ce24ca-2c74336e-eea51b51&quot; VERSION&#x3D;&quot;4.0&quot; MOUNT&#x3D;&quot;&#x2F;rom&quot; TYPE&#x3D;&quot;squashfs&quot;</span><br><span class="line">&#x2F;dev&#x2F;mtdblock6: MOUNT&#x3D;&quot;&#x2F;overlay&quot; TYPE&#x3D;&quot;jffs2&quot;</span><br><span class="line">&#x2F;dev&#x2F;mmcblk0p1: UUID&#x3D;&quot;746ffc51-1f29-2646-b2cb-fc2c03fe3c1a&quot; LABEL&#x3D;&quot;sdcard&quot; VERSION&#x3D;&quot;1.0&quot; TYPE&#x3D;&quot;ext4&quot;</span><br></pre></td></tr></table></figure><p>格式化内存卡</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/mmcblk0p1</span><br></pre></td></tr></table></figure><p>将下面的DEVICE换成你的sd卡分区</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=<span class="string">&quot;/dev/mmcblk0p1&quot;</span></span><br><span class="line"><span class="built_in">eval</span> $(block info <span class="string">&quot;<span class="variable">$&#123;DEVICE&#125;</span>&quot;</span> | grep -o -e <span class="string">&quot;UUID=\S*&quot;</span>)</span><br><span class="line">uci -q delete fstab.overlay</span><br><span class="line">uci <span class="built_in">set</span> fstab.overlay=<span class="string">&quot;mount&quot;</span></span><br><span class="line">uci <span class="built_in">set</span> fstab.overlay.uuid=<span class="string">&quot;<span class="variable">$&#123;UUID&#125;</span>&quot;</span></span><br><span class="line">uci <span class="built_in">set</span> fstab.overlay.target=<span class="string">&quot;/overlay&quot;</span></span><br><span class="line">uci commit fstab</span><br></pre></td></tr></table></figure><p>转移数据</p><p>如有报错请先查看否自动挂载了sd卡，挂载sd卡时也可能出现如下报错，实测不影响。</p><p>报错信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@GL-MT1300:~<span class="comment"># mount /dev/mmcblk0p1 /mnt/</span></span><br><span class="line">NTFS signature is missing.</span><br><span class="line">Failed to mount <span class="string">&#x27;/dev/mmcblk0p1&#x27;</span>: Invalid argument</span><br><span class="line">The device <span class="string">&#x27;/dev/mmcblk0p1&#x27;</span> doesn<span class="string">&#x27;t seem to have a valid NTFS.</span></span><br><span class="line"><span class="string">Maybe the wrong device is used? Or the whole disk instead of a</span></span><br><span class="line"><span class="string">partition (e.g. /dev/sda, not /dev/sda1)? Or the other way around?</span></span><br></pre></td></tr></table></figure><p>执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;mmcblk0p1 &#x2F;mnt</span><br><span class="line">cp -f -a &#x2F;overlay&#x2F;. &#x2F;mnt</span><br><span class="line">umount &#x2F;mnt</span><br></pre></td></tr></table></figure><p>然后重启</p><p>扩展分区前</p><figure><img src="https://ftp.fly97.cn/image/image-20210122191844339.png" alt="image-20210122191844339" /><figcaption>image-20210122191844339</figcaption></figure><p>扩展分区后</p><figure><img src="https://ftp.fly97.cn/image/image-20210122191907269.png" alt="image-20210122191907269" /><figcaption>image-20210122191907269</figcaption></figure><h3 id="单独编译openwrt-ipk">单独编译openwrt ipk</h3><p>先执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig </span><br></pre></td></tr></table></figure><p>然后选中相关组件</p><p>再执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make package&#x2F;feeds&#x2F;luci&#x2F;luci-base&#x2F;compile -j1 V&#x3D;s</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是OpenWRT？&lt;/p&gt;</summary>
    
    
    
    
    <category term="MT7621" scheme="https://www.fly97.cn/tags/MT7621/"/>
    
    <category term="OpenWRT" scheme="https://www.fly97.cn/tags/OpenWRT/"/>
    
  </entry>
  
  <entry>
    <title>ssh-genkey参数</title>
    <link href="https://www.fly97.cn/p/ssh-genkey/"/>
    <id>https://www.fly97.cn/p/ssh-genkey/</id>
    <published>2021-01-23T06:29:00.000Z</published>
    <updated>2021-01-23T06:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是ssh-genkey？</p><p>ssh 公钥认证是ssh认证的方式之一。通过公钥认证可实现ssh免密码登陆，git的ssh方式也是通过公钥进行认证的。</p><p>在用户目录的home目录下，有一个<code>.ssh</code>的目录，和当前用户ssh配置认证相关的文件，几乎都在这个目录下。</p><p><code>ssh-keygen</code> 可用来生成ssh公钥认证所需的公钥和私钥文件。</p><a id="more"></a><h2 id="常用命令">常用命令</h2><h3 id="生成密钥对">生成密钥对</h3><p>默认生成 2048 位 RSA 密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>生成 4096 位 RSA 密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure><p>生成 521 位 ECDSA 密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ecdsa -b 521</span><br></pre></td></tr></table></figure><h3 id="私钥生成公钥">私钥生成公钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -y -f [private-key-path] &gt; [output-path]</span><br></pre></td></tr></table></figure><p>比如，有一个文件名为 <code>id_rsa</code> 私钥，想用它生成 <code>id_rsa.pub</code> 公钥</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是ssh-genkey？&lt;/p&gt;
&lt;p&gt;ssh 公钥认证是ssh认证的方式之一。通过公钥认证可实现ssh免密码登陆，git的ssh方式也是通过公钥进行认证的。&lt;/p&gt;
&lt;p&gt;在用户目录的home目录下，有一个&lt;code&gt;.ssh&lt;/code&gt;的目录，和当前用户ssh配置认证相关的文件，几乎都在这个目录下。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh-keygen&lt;/code&gt; 可用来生成ssh公钥认证所需的公钥和私钥文件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ssh-genkey" scheme="https://www.fly97.cn/tags/ssh-genkey/"/>
    
  </entry>
  
  <entry>
    <title>Proxmox VE显卡直通</title>
    <link href="https://www.fly97.cn/p/pve-pci-passthrough/"/>
    <id>https://www.fly97.cn/p/pve-pci-passthrough/</id>
    <published>2021-01-12T05:21:00.000Z</published>
    <updated>2021-01-12T05:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是PVE？</p><p>Proxmox VE是一个既可以运行虚拟机也可以运行容器的虚拟化平台。Proxmox VE基于Debian Linux 开发，而且完全开源。处于灵活性的考虑，Proxmox VE同时支持两种虚拟化技术：KVM虚拟机和LXC容器。以下操作基于KVM虚拟机。</p><a id="more"></a><p><strong>任务背景：</strong>实验室有一台闲置的服务器，配置是64GB内存，10GB NVIDIA RTX 2080 Ti 显卡，i9-10900K 20核CPU。组内有师姐需要跑深度学习代码，而师兄的项目需要在服务器上运行数据库。为了实现数据隔离（生产环境不影响开发环境），考虑了一下两种方案：</p><p>1.Docker方案。服务器装ubuntu系统，每个任务运行一个docker 容器。优点是运行任务简单，直接<code>docker pull</code> 相应的容器即可。缺点对于不熟悉docker运维的人来说，维护相对复杂，有些任务需要持久化，需要将不同容器的不同目录映射到ubuntu下的目录。这样无法实现数据隔离，违背了初衷，而且无法实现<code>ip</code>直接访问，需要设置端口映射。遂放弃。</p><p>2.PVE-KVM方案。宿主机安装基于<code>debian</code>的<code>Proxmox VE</code>操作系统，不同的任务创建不同的客户机，根据<code>VM ID</code>和<code>ip</code>区分客户机。缺点是配置复杂。<strong><font color="red">不过生命在于折腾，生命不止，折腾不息。</font></strong></p><h4 id="准备工作">准备工作</h4><p>检查CPU是否支持VT-d ： https://ark.intel.com/content/www/cn/zh/ark.html</p><p><img src="https://ftp.fly97.cn/image/image-20210112135114468.png" /></p><h4 id="创建虚拟机">创建虚拟机</h4><p>千万注意不要设置自启动！！</p><p><img src="https://ftp.fly97.cn/image/image-20210112135351055.png" /></p><p>选择自己上传的系统镜像，这里以Ubuntu 2004为例。</p><p><img src="https://ftp.fly97.cn/image/image-20210112135506814.png" /></p><p>设置系统选项，注意使用<font color="red"><strong>EFI模式</strong></font></p><p><img src="https://ftp.fly97.cn/image/image-20210112140758741.png" /></p><p>选择CPU时，请根据你的CPU核心数选择。类别选择host。此种模式下客户机下可以看到当前CPU的型号，同时尽量保证虚拟机内的CPU指令集和宿主机内一致。</p><p><img src="https://ftp.fly97.cn/image/image-20210112140906881.png" /></p><p><strong>网络选择：</strong>一般情况下选择默认即可。默认是网桥接入。网桥相当于一个软件实现的物理交换机。所有虚拟机共享一个网桥。网桥接入模式下，可以在上一级网关设备查看当前客户机的IP地址。</p><p><img src="https://ftp.fly97.cn/image/image-20210112141534116.png" /></p><p>确认设置，<strong>先不要开启虚拟机</strong>。</p><p><img src="https://ftp.fly97.cn/image/image-20210112141614131.png" /></p><h4 id="配置显卡直通">配置显卡直通</h4><p>首先编辑GRUB配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/default/grub</span><br></pre></td></tr></table></figure><p>开启开启IOMMU支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT&#x3D;&quot;quiet intel_iommu&#x3D;on video&#x3D;efifb:off&quot;</span><br></pre></td></tr></table></figure><p>如果是AMD的CPU：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT&#x3D;&quot;quiet amd_iommu&#x3D;on video&#x3D;efifb:off&quot;</span><br></pre></td></tr></table></figure><p>我是Intel的CPU，因此修改为：</p><p><img src="https://ftp.fly97.cn/image/image-20210112142014140.png" /></p><p>更新GRUB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-grub</span><br></pre></td></tr></table></figure><p>添加所需的系统模块（驱动）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;vfio&quot;</span> &gt;&gt; /etc/modules</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;vfio_iommu_type1&quot;</span> &gt;&gt; /etc/modules</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;vfio_pci&quot;</span> &gt;&gt; /etc/modules</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;vfio_virqfd&quot;</span> &gt;&gt; /etc/modules</span><br></pre></td></tr></table></figure><p>接着添加模块（驱动）黑名单，即让GPU设备在下次系统启动之后不使用这些驱动，把设备腾出来给<code>vfio</code>驱动用：</p><p>N卡/A卡：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;blacklist nouveau&quot;</span> &gt;&gt; /etc/modprobe.d/pve-blacklist.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;blacklist nvidiafb&quot;</span> &gt;&gt; /etc/modprobe.d/pve-blacklist.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;blacklist radeon&quot;</span> &gt;&gt; /etc/modprobe.d/pve-blacklist.conf</span><br></pre></td></tr></table></figure><p>如果是N卡还需要加入下面的配置到kvm.conf（据老外说是避免一些莫名其妙的错误）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;options vfio_iommu_type1 allow_unsafe_interrupts&#x3D;1&quot; &gt; &#x2F;etc&#x2F;modprobe.d&#x2F;iommu_unsafe_interrupts.conf</span><br><span class="line">echo &quot;options kvm ignore_msrs&#x3D;1&quot; &gt; &#x2F;etc&#x2F;modprobe.d&#x2F;kvm.conf</span><br></pre></td></tr></table></figure><p>更新内核：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-initramfs -u</span><br></pre></td></tr></table></figure><p>重启机器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>重启上来之后检查模块是否正常加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep vfio</span><br></pre></td></tr></table></figure><p>成功的话有类似回显：</p><p><img src="https://ftp.fly97.cn/image/image-20210112142429876.png" /></p><p>查看GPU设备ID：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -nn | grep VGA</span><br></pre></td></tr></table></figure><p>会有类似的回显：</p><p><img src="https://ftp.fly97.cn/image/image-20210112142511212.png" /></p><p>再执行下面的命令<strong>(01:00.0请替换成你的显卡ID)</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -vvv -s 01:00.0</span><br></pre></td></tr></table></figure><p>会有类似的回显：</p><p><img src="https://ftp.fly97.cn/image/image-20210112152426155.png" /></p><p><img src="https://ftp.fly97.cn/image/image-20210112152400447.png" /></p><p>现在把需要直通给虚拟机的设备ID写到vfio.conf内，注意这次这里的ID不是01:00.0而是自己查看自己设备的ID，ID查看在上面回显里：</p><p><img src="https://ftp.fly97.cn/image/image-20210112152916014.png" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;options vfio-pci ids=10de:1e07&quot;</span> &gt;&gt; /etc/modprobe.d/vfio.conf</span><br></pre></td></tr></table></figure><p>然后应用更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update-grub</span><br><span class="line">update-initramfs</span><br></pre></td></tr></table></figure><h4 id="更改虚拟机主机类型">更改虚拟机主机类型</h4><p>其中100 是VM ID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qm set 100 -machine pc-q35-3.1</span><br></pre></td></tr></table></figure><h4 id="添加显卡">添加显卡</h4><p>添加PCI设备，注意ID要选择你的电脑对应的显卡ID。注意不要添加成其他设备，如Audio device等。</p><p><img src="https://ftp.fly97.cn/image/image-20210112153802857.png" /></p><p><img src="https://ftp.fly97.cn/image/image-20210112154050976.png" /></p><h4 id="安装操作系统">安装操作系统</h4><p>此过程略</p><h4 id="伪装cpu">伪装CPU</h4><p>由于NVIDIA官方限制在虚拟机中使用显卡，通过修改CPU类型，可以达到欺骗NVIDIA显卡驱动的目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/pve/qemu-server/&lt;你的虚拟机的ID&gt;.conf</span><br></pre></td></tr></table></figure><p>找到CPU那一行，删掉，然后改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpu: host,hidden&#x3D;1,flags&#x3D;+pcid</span><br><span class="line">args: -cpu &#39;host,+kvm_pv_unhalt,+kvm_pv_eoi,hv_vendor_id&#x3D;NV43FIX,kvm&#x3D;off&#39;</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="https://ftp.fly97.cn/image/image-20210112154651328.png" /></p><h4 id="安装显卡驱动">安装显卡驱动</h4><p>以下操作是在<font color="red">客户机</font>上完成的，根据显卡选择合适的驱动安装。</p><p><img src="https://ftp.fly97.cn/image/image-20210112155127152.png" /></p><p>安装完毕，重启客户机。执行一下命令查看驱动是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>有下图所示回显说明安装成功：</p><p><img src="https://ftp.fly97.cn/image/image-20210112155315385.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是PVE？&lt;/p&gt;
&lt;p&gt;Proxmox VE是一个既可以运行虚拟机也可以运行容器的虚拟化平台。Proxmox VE基于Debian Linux 开发，而且完全开源。处于灵活性的考虑，Proxmox VE同时支持两种虚拟化技术：KVM虚拟机和LXC容器。以下操作基于KVM虚拟机。&lt;/p&gt;</summary>
    
    
    
    
    <category term="PVE" scheme="https://www.fly97.cn/tags/PVE/"/>
    
    <category term="Proxmox VE" scheme="https://www.fly97.cn/tags/Proxmox-VE/"/>
    
  </entry>
  
  <entry>
    <title>Jetson Xavier 开发实录</title>
    <link href="https://www.fly97.cn/p/How-to-use-Jetson-Xavier/"/>
    <id>https://www.fly97.cn/p/How-to-use-Jetson-Xavier/</id>
    <published>2020-12-07T10:51:00.000Z</published>
    <updated>2020-12-07T10:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>最近实验室买了两块嵌入式NVIDIA Jetson Xavie NX 开发板，学长拿来让我折腾下，遂有了这篇文章。</p><p><strong>关键词：</strong>Jetson，NVIDIA，CUDA</p><a id="more"></a><h3 id="介绍">介绍</h3><p>略</p><h3 id="制作启动盘">制作启动盘</h3><p>NVIDIA Jetson Xavie NX镜像下载地址：https://developer.nvidia.com/zh-cn/embedded/downloads</p><p>板子使用的是SD卡作为引导盘和存储盘的，首先要格式化内存卡。使用<strong>SD Card Formatter</strong>格式化内存卡。<a href="https://www.sdcard.org/downloads/formatter/eula_windows/">SD Card Formatter下载地址</a></p><p>格式化时注意<strong>盘符</strong>，随后点击<strong>Format</strong>.</p><h4 id="烧录镜像到内存卡">烧录镜像到内存卡</h4><p>使用<strong>balenaEtcher</strong>软件烧录镜像。下载地址：https://www.balena.io/etcher/</p><p>选择下载好的<strong>jetson-nx-jp441-sd-card-image</strong>文件，点击Flash.</p><p>刷写完以后会有一个验证数据的操作，不建议跳过。</p><p>稍后片刻，等待完成。</p><h3 id="点亮主机">点亮主机</h3><p>把SD卡插入卡槽，将HDMI线连接到屏幕上，插入鼠标和键盘，启动电源。</p><h3 id="初始配置">初始配置</h3><h4 id="采用m.2-key-m-ssd作为启动盘">采用M.2 Key M SSD作为启动盘</h4><ol type="1"><li><p>打开Ubuntu18.04自带 Disks 工具，'Ctrl+F' 或点击右上角选择‘Format Disk' 并将其格式化为GPT 格式</p></li><li><p>格式化时必须选择“Ext4”， 等待完成后，点击下方 '三角按钮'，mount 到固定目录如<code>/media/nvidia/xxxx</code></p></li><li><p>执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/jetsonhacks/rootOnNVMe.git</span><br><span class="line"><span class="built_in">cd</span> rootOnNVMe</span><br><span class="line">./copy-rootfs-ssd.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./setup-service.sh</span><br></pre></td></tr></table></figure></li></ol><h4 id="更改apt源">更改apt源</h4><p>感谢<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像</a>对开源软件的大力支持。</p><p>备份原有源文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure><p>将以下内容粘贴到终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu-ports&#x2F; bionic main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu-ports&#x2F; bionic main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu-ports&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu-ports&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu-ports&#x2F; bionic-backports main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu-ports&#x2F; bionic-backports main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu-ports&#x2F; bionic-security main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu-ports&#x2F; bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu-ports&#x2F; bionic-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu-ports&#x2F; bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>更新系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br></pre></td></tr></table></figure><h4 id="更改pypi源">更改pypi源</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo install python3-pip</span><br><span class="line">python3 -m pip install -i https://mirrors.cloud.tencent.com/pypi/simple --upgrade pip</span><br><span class="line">python3 -m pip install config set <span class="keyword">global</span>.index-url https://mirrors.cloud.tencent.com/pypi/simple</span><br></pre></td></tr></table></figure><h4 id="风扇控制">风扇控制</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 255 &gt; /sys/devices/pwm-fan/target_pwm</span><br><span class="line"><span class="comment">#范围0-255,风扇默认是不开的</span></span><br></pre></td></tr></table></figure><p>重启以后风扇是不转的，所以需要设置开机运行： 创建<code>/etc/rc.local</code>，并添加如下内容： （注：系统启动的时候会执行<code>/etc/rc.local</code>，如果已存在rc.local，则在<code>exit 0</code>之前加入那3句命令即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">sleep 10</span><br><span class="line">sudo /usr/bin/jetson_clocks</span><br><span class="line">sudo sh -c <span class="string">&#x27;echo 255 &gt; /sys/devices/pwm-fan/target_pwm&#x27;</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>添加执行权限： <code>sudo chmod 755 /etc/rc.local</code></p><p>以后重启就会自动开启最大性能并启动风扇了。</p><h4 id="远程桌面">远程桌面</h4><p>开机以后SSH默认是开启的。这里使用Nomachine作为远程桌面软件。Nomachine的专有NX协议在高延迟低带宽的链路上提供了近乎本地速度的响应能力。</p><p><a href="https://fly97.coding.net/p/github-projects/d/nomachine/git/raw/master/nomachine_6.12.3_5_arm64.deb">ARM64客户端下载链接</a></p><p><a href="https://fly97.coding.net/p/github-projects/d/nomachine/git/raw/master/nomachine_6.12.3_7.exe">Windows客户端下载链接</a></p><h4 id="设置分辨率">设置分辨率</h4><p>如果没有显示器连接，默认VNC 连接后的分辨率为640x480 ，将以下内容添加到<code>/etc/X11/xorg.conf</code>文件，将其设置为默认VNC分辨率设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Section <span class="string">&quot;Screen&quot;</span></span><br><span class="line">   Identifier    <span class="string">&quot;Default Screen&quot;</span></span><br><span class="line">   Monitor       <span class="string">&quot;Configured Monitor&quot;</span></span><br><span class="line">   Device        <span class="string">&quot;Tegra0&quot;</span></span><br><span class="line">   SubSection <span class="string">&quot;Display&quot;</span></span><br><span class="line">       Depth    24</span><br><span class="line">       Virtual 1024 768 <span class="comment"># Modify the resolution by editing these values</span></span><br><span class="line">   EndSubSection</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure><h4 id="快捷设置代理">快捷设置代理</h4><p>在<code>/home</code>目录下，把一下内容加入到<code>.bashrc</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> proxy=<span class="string">&#x27;export all_proxy=http://127.0.0.1:10809</span></span><br><span class="line"><span class="string">export https_proxy=http://127.0.0.1:10809</span></span><br><span class="line"><span class="string">export socks_proxy=socks5://127.0.0.1:10808&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">&#x27;unset all_proxy https_proxy socks_proxy&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="安装jtop">安装Jtop</h4><p>Jtop（一个系统监视实用程序，可在终端上运行，并实时查看和控制 NVIDIA Jetson的状态 ）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip</span><br><span class="line">sudo pip3 install jetson-stats </span><br><span class="line">sudo jtop</span><br></pre></td></tr></table></figure><h4 id="查看当前运行功率">查看当前运行功率</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询当前状态</span></span><br><span class="line">sudo nvpmodel --query</span><br><span class="line"><span class="comment">#切换状态</span></span><br><span class="line">sudo nvpmodel -m <span class="comment">#Mode_ID</span></span><br><span class="line"><span class="comment">#查看处理器状态</span></span><br><span class="line">sudo jetson_clocks --show</span><br><span class="line"><span class="comment">#如果jetson_clocks 后没有参数，则直接开启static MAX 模式</span></span><br><span class="line">sudo jetson=_clocks</span><br></pre></td></tr></table></figure><h4 id="安装pytorch">安装Pytorch</h4><p><a href="https://forums.developer.nvidia.com/t/pytorch-for-jetson-version-1-7-0-now-available/72048">下载地址</a></p><p><a href="https://wf09.coding.net/p/jetson/d/Pytorch/git/raw/master/torch-1.7.0-cp36-cp36m-linux_aarch64.whl">备用地址</a></p><p>根据自己的Python环境下载whl文件.这里是Python 3.6.9，安装的版本是PyTorch v1.7。</p><p>安装命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip libopenblas-base libopenmpi-dev </span><br><span class="line">python3 -m pip install Cython</span><br><span class="line">python3 -m pip install numpy torch-1.7.0-cp36-cp36m-linux_aarch64.whl</span><br></pre></td></tr></table></figure><h5 id="安装torchvision">安装torchvision</h5><p>以<strong>v0.8.1</strong>为例.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libjpeg-dev zlib1g-dev libpython3-dev libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">git <span class="built_in">clone</span> --branch v0.8.1 https://e.coding.net/fly97/mechine-learning/torchvision.git   <span class="comment"># see below for version of torchvision to download</span></span><br><span class="line"><span class="built_in">cd</span> torchvision</span><br><span class="line"><span class="built_in">export</span> BUILD_VERSION=v0.8.1  <span class="comment"># where 0.x.0 is the torchvision version</span></span><br><span class="line">python3 -m pip  <span class="string">&#x27;pillow&lt;7&#x27;</span> <span class="comment"># always needed for Python 2.7, not needed torchvision v0.5.0+ with Python 3.6</span></span><br><span class="line">sudo python setup.py install     <span class="comment"># use python3 if installing for Python 3.6</span></span><br><span class="line"><span class="built_in">cd</span> ../  <span class="comment"># attempting to load torchvision from build dir will result in import error</span></span><br></pre></td></tr></table></figure><p>对应版本：</p><ul><li>PyTorch v1.0 - torchvision v0.2.2</li><li>PyTorch v1.1 - torchvision v0.3.0</li><li>PyTorch v1.2 - torchvision v0.4.0</li><li>PyTorch v1.3 - torchvision v0.4.2</li><li>PyTorch v1.4 - torchvision v0.5.0</li><li>PyTorch v1.5 - torchvision v0.6.0</li><li>PyTorch v1.6 - torchvision v0.7.0</li><li>PyTorch v1.7 - torchvision v0.8.1</li></ul><h4 id="cuda">CUDA</h4><p>官网最新镜像文件自带cuda 版本为10.2，OpenCV4</p><p>将以下命令写入<code>~/.bashrc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CUDA_HOME=/usr/<span class="built_in">local</span>/cuda-10.2</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda-10.2/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda-10.2/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>退出后保存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>检查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><p>返回的文字如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2019 NVIDIA Corporation</span><br><span class="line">Built on Wed_Oct_23_21:14:42_PDT_2019</span><br><span class="line">Cuda compilation tools, release 10.2, V10.2.89</span><br></pre></td></tr></table></figure><h5 id="安装ros仓库">安装ROS仓库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.bfsu.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="添加ros密钥">添加ROS密钥</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver &#39;hkp:&#x2F;&#x2F;keyserver.ubuntu.com:80&#39; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure><h5 id="启用额外的软件库">启用额外的软件库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-add-repository universe</span><br><span class="line">sudo apt-add-repository multiverse</span><br><span class="line">sudo apt-add-repository restricted</span><br></pre></td></tr></table></figure><h5 id="添加ros">添加ROS</h5><h4 id="opencv">OpenCV</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config opencv4 --modversion</span><br></pre></td></tr></table></figure><p>返回的文字如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.1.1</span><br></pre></td></tr></table></figure><h5 id="安装cuda-opencv">安装CUDA OpenCV</h5><h6 id="移除原有opencv">移除原有OpenCV</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> purge libopencv*</span><br><span class="line">sudo apt autoremove                  <span class="meta">#此步不建议运行, 有可能产生奇怪的依赖问题</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> update</span><br></pre></td></tr></table></figure><h6 id="安装依赖">安装依赖</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 安装必备库，cmake,git,g++</span><br><span class="line">sudo apt-get install -y build-essential checkinstall cmake pkg-config yasm git gfortran</span><br><span class="line">sudo apt-get install -y libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev</span><br><span class="line">sudo apt-get install -y libjpeg8-dev libjasper-dev libpng12-dev libtiff5-dev libavcodec-dev libavformat-dev libswscale-dev libdc1394-22-dev libxine2-dev libv4l-dev</span><br><span class="line">sudo apt-get install -y libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libgtk2.0-dev libtbb-dev libatlas-base-dev libfaac-dev libmp3lame-dev libtheora-dev libvorbis-dev libxvidcore-dev libopencore-amrnb-dev libopencore-amrwb-dev x264 v4l-utils</span><br><span class="line"># 处理图像所需的包</span><br><span class="line">sudo apt-get install libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev </span><br><span class="line"># 处理视频所需的包</span><br><span class="line">sudo apt-get install libxvidcore-dev libx264-dev ffmpeg</span><br><span class="line"># opencv功能优化</span><br><span class="line">sudo apt-get install libatlas-base-dev gfortran </span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="下载opencv源代码">下载OpenCV源代码</h6><p>下载地址：https://opencv.org/releases/</p><p>此次编译使用的是<code>opencv-4.4.0.zip</code>版本。</p><p>额外的库：https://github.com/opencv/opencv_contrib</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unzip opencv-4.4.0.zip</span><br><span class="line"><span class="built_in">cd</span> opencv-4.4.0</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure><p>执行CMAKE</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cmake \</span><br><span class="line">-DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">-DCMAKE_INSTALL_PREFIX=/usr/local \</span><br><span class="line">-DOPENCV_ENABLE_NONFREE=1 \</span><br><span class="line">-DBUILD_opencv_python2=1 \</span><br><span class="line">-DBUILD_opencv_python3=1 \</span><br><span class="line">-DWITH_FFMPEG=1 \</span><br><span class="line">-DCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda-10.2 \</span><br><span class="line">-DCUDA_ARCH_BIN=7.2 \</span><br><span class="line">-DCUDA_ARCH_PTX=7.2 \</span><br><span class="line">-DWITH_CUDA=1 \</span><br><span class="line">-DENABLE_FAST_MATH=1 \</span><br><span class="line">-DCUDA_FAST_MATH=1 \</span><br><span class="line">-DWITH_CUBLAS=1 \</span><br><span class="line">-DOPENCV_GENERATE_PKGCONFIG=1 \</span><br><span class="line">-DOPENCV_EXTRA_MODULES_PATH=../opencv_contrib-4.4.0/modules \</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>注意<strong>：opencv_contrib-4.4.0是放在opencv-4.4.0中，注意文件的路径！！！</strong></p><p><strong>使用cuda，-DWITH_CUDA=1.</strong></p><p>官方文档的cmake的配置情况：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cmake \</span><br><span class="line">-DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">-DCMAKE_INSTALL_PREFIX=<span class="regexp">/usr \</span></span><br><span class="line"><span class="regexp">-DBUILD_PNG=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_TIFF=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_TBB=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_JPEG=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_JASPER=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_ZLIB=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_EXAMPLES=ON \</span></span><br><span class="line"><span class="regexp">-DBUILD_JAVA=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_opencv_python2=ON \</span></span><br><span class="line"><span class="regexp">-DBUILD_opencv_python3=OFF \</span></span><br><span class="line"><span class="regexp">-DENABLE_NEON=ON \</span></span><br><span class="line"><span class="regexp">-DWITH_OPENCL=OFF \</span></span><br><span class="line"><span class="regexp">-DWITH_OPENMP=OFF \</span></span><br><span class="line"><span class="regexp">-DWITH_FFMPEG=ON \</span></span><br><span class="line"><span class="regexp">-DWITH_GSTREAMER=OFF \</span></span><br><span class="line"><span class="regexp">-DWITH_GSTREAMER_0_10=OFF \</span></span><br><span class="line"><span class="regexp">-DWITH_CUDA=ON \</span></span><br><span class="line"><span class="regexp">-DWITH_GTK=ON \</span></span><br><span class="line"><span class="regexp">-DWITH_VTK=OFF \</span></span><br><span class="line"><span class="regexp">-DWITH_TBB=ON \</span></span><br><span class="line"><span class="regexp">-DWITH_1394=OFF \</span></span><br><span class="line"><span class="regexp">-DWITH_OPENEXR=OFF \</span></span><br><span class="line"><span class="regexp">-DCUDA_TOOLKIT_ROOT_DIR=/usr</span><span class="regexp">/local/cuda</span>-<span class="number">8.0</span> \</span><br><span class="line">-DCUDA_ARCH_BIN=<span class="number">6.2</span> \</span><br><span class="line">-DCUDA_ARCH_PTX=<span class="string">&quot;&quot;</span> \</span><br><span class="line">-DINSTALL_C_EXAMPLES=ON \</span><br><span class="line">-DINSTALL_TESTS=OFF \</span><br><span class="line">-DOPENCV_TEST_DATA_PATH=../opencv_extra/testdata \</span><br><span class="line">../opencv</span><br></pre></td></tr></table></figure><p>注意：<strong>请根据自己的的CUDA版本和实际路径修改参数！</strong></p><p>参考链接：<a href="https://docs.opencv.org/4.4.0/d6/d15/tutorial_building_tegra_cuda.html#tutorial_building_tegra_cuda_installing">OpenCV: Building OpenCV for Tegra with CUDA</a></p><h6 id="编译">编译</h6><p>执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j1</span><br></pre></td></tr></table></figure><p>其中1指的线程，初次编译建议使用单线程,，解决一些奇怪问题。</p><h6 id="安装">安装</h6><p>执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h6 id="成功啦">成功啦</h6><p><img src="https://fly97.coding.net/p/images/d/fly97.cn/git/raw/master/20210318/success.png" /></p><h6 id="解决各种出错问题">解决各种出错问题</h6><ol type="1"><li><strong>src/grfmt_jpeg2000.cpp.o failed</strong></li></ol><p><img src="https://fly97.coding.net/p/images/d/fly97.cn/git/raw/master/20210318/bug.png" /></p><p>编译时关闭如下tag：<strong>-DBUILD_JASPER=OFF</strong> 即可.</p><ol start="2" type="1"><li><p><strong>fatal error: boostdesc_bgm.i: No such file or directory</strong></p><p>可参考：https://github.com/AastaNV/JEP/issues/20</p><p>https://github.com/opencv/opencv_contrib/issues/1301#issuecomment-618262386</p></li></ol><p>将下载好的文件解压到以下文件夹：</p><p><img src="https://fly97.coding.net/p/images/d/fly97.cn/git/raw/master/20210318/issue.png" /></p><h4 id="cudnn">cuDNN</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/cudnn_samples_v8/mnistCUDNN</span><br><span class="line">sudo make</span><br><span class="line">sudo chmod a+x mnistCUDNN</span><br><span class="line">./mnistCUDNN</span><br></pre></td></tr></table></figure><h4 id="更改桌面">更改桌面</h4><p>默认的桌面环境是Unity，此次更改成更轻量的<code>ubuntu-mate</code>.</p><p>注意：安装过程中请勿卸载现有的桌面登录管理器，以免出现无法登录进系统的尴尬。</p><p>安装更轻量的桌面登录管理器<strong>LightDM</strong>：LightDM是2010年开始的新项目，且被设计为轻量、小巧、快速。相较于GDM-GTK、KDM-Qt、LightDM实际上与界面无关，它仅支持本地图形界面获得最好兼容性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lightdm</span><br></pre></td></tr></table></figure><p>安装<code>ubuntu-mate-destop</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ubuntu-mate-core ubuntu-mate-desktop</span><br></pre></td></tr></table></figure><h5 id="lightdm设置自动登录">lightdm设置自动登录</h5><p>设置<strong>autologin-user</strong>来设置系统启动时自动登录某个帐户。设置<strong>autologin-user-timeout</strong>限制用户在设定秒内如果没有自动登录则不能自动登录。</p><p>编辑以下文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;lightdm&#x2F;lightdm.conf </span><br></pre></td></tr></table></figure><p>设置<strong>autologin-user</strong>来设置系统启动时自动登录某个帐户。设置<strong>autologin-user-timeout</strong>限制用户在设定秒内如果没有自动登录则不能自动登录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[SeatDefaults]</span><br><span class="line">autologin-user&#x3D;username</span><br><span class="line">autologin-user-timeout&#x3D;delay</span><br></pre></td></tr></table></figure><h5 id="lightdm修改默认会话"><strong>lightdm修改默认会话</strong></h5><p>默认会话设置保存在<strong>/usr/share/lightdm/lightdm.conf.d</strong>会话包中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SeatDefaults]</span><br><span class="line">user-session&#x3D;name</span><br></pre></td></tr></table></figure><p>其中name代表<strong>/usr/share/xsessions/*.desktop</strong>中<name>.desktop。</p><p>转载自：https://www.cnblogs.com/EasonJim/p/7128317.html</p><h4 id="sudo无需输入密码">sudo无需输入密码</h4><p>切换到<code>root</code>用户，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure><p>在最后一行输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;用户名&gt; ALL&#x3D;(ALL) NOPASSWD: ALL </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;最近实验室买了两块嵌入式NVIDIA Jetson Xavie NX 开发板，学长拿来让我折腾下，遂有了这篇文章。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词：&lt;/strong&gt;Jetson，NVIDIA，CUDA&lt;/p&gt;</summary>
    
    
    
    
    <category term="Jetson" scheme="https://www.fly97.cn/tags/Jetson/"/>
    
    <category term="NVIDIA" scheme="https://www.fly97.cn/tags/NVIDIA/"/>
    
  </entry>
  
  <entry>
    <title>梯度下降法</title>
    <link href="https://www.fly97.cn/p/What&#39;s-the-Gradient-descent/"/>
    <id>https://www.fly97.cn/p/What&#39;s-the-Gradient-descent/</id>
    <published>2020-12-07T10:51:00.000Z</published>
    <updated>2020-12-07T10:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>梯度下降法，是当今最流行的最优化（optimization）算法，亦是至今最常用的最优化神经网络的方法。与此同时，最新的深度学习程序库都包含了各种优化梯度下降的算法（可以参见如 Pytorch 程序库的说明文档）。但他们的算法则不被公开，都作为黑箱优化器被使用，这也就是为什么它们的优势和劣势往往难以被实际地解释。</p><p><strong>关键词：</strong>Deep Learning</p><a id="more"></a><h3 id="核心">核心</h3><p>梯度下降法的核心，是最小化目标函数。方法是在每一次迭代中，对每个变量，按照目标函数在该变量梯度的相反方向，更新对应的参数值，其中，学习率决定了函数到达局部最小值的迭代次数。<strong>我们在目标函数的超平面上，沿着斜率下降的方向前进，直到我们遇到了超平面构成的"谷底"。</strong></p><h3 id="梯度下降法的变体">梯度下降法的变体</h3><p>梯度下降法有三种变体，它们的区别在于用多少数据来计算目标函数的梯度。根据数据量的不同，我们需要权衡参数更新的准确性和执行一次所需要的时间。</p><h4 id="batch-gradient-descent-批量梯度下降">Batch gradient descent 批量梯度下降</h4><p>批量梯度下降又称<strong>Vanilla梯度下降法</strong>，也就是所谓的批量梯度下降法，在整个数据集上对每个参数求目标函数的偏导数。 <span class="math display">\[\theta=\theta-\eta{\nabla_\theta}J(\theta)\]</span> 翻译成白话文就是：用整个训练集计算目标函数的梯度参数。</p><p>由于我们需要计算整个数据集的梯度来执行一次更新，因此批量梯度下降可能非常缓慢。而且需要把数据集放入内存。批量梯度下降也不允许我们在线更新我们的的模型。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">    params_grad = evaluate_gradient(loss_function, data, params)</span><br><span class="line">    params = params - lr * params_grad</span><br></pre></td></tr></table></figure><p>对于预先定义的多个epoch，我们首先计算关于整个数据集的损失函数的梯度向量<code>param_grad</code>.当前的一些深度学习库提供了自动求导的函数，可以有效的计算一些参数梯度。</p><p>按照梯度的反方向更新参数，学习速率决定我们执行的更新的大小。保证了批梯度下降收敛于凸误差曲面的全局最小值和非凸曲面的全局最小值。</p><h4 id="stochastic-gradient-descent-随机梯度下降">Stochastic gradient descent 随机梯度下降</h4><p>相比之下，随机梯度下降(SGD)对每个训练示例和标号进行参数更新： <span class="math display">\[\theta=\theta-\eta{\nabla_\theta}J(\theta;x^{(i)};y^{(i)})\]</span> 批量梯度下降对大数据集会有一些冗余计算，因此它在每次参数更新前重新计算类似的梯度。</p><p><strong>随机梯度下降</strong>会以一个较大的方差执行频繁的更新，导致目标函数剧烈波动，如下图所示。</p><p><img src="https://ftp.fly97.cn/image/sgd_fluctuation.png" /></p><p>当批量梯度下降法收敛到参数的盆地时，SGD的波动一方面会使其跳跃到新的、可能的更好的局部极小值。另一方面，这最终会使让收敛到特定最小值的过程复杂化，因为该方法可能持续的波动而不停止。但是，当我们慢慢降低学习率时，SGD表现出了与批量梯度下降法相似的收敛过程，也就是说，对非凸函数和凸函数，必然会分别收敛到他们的极小值和最小值。</p><p>相比批量梯度下降法的代码，在如下的代码中，我们仅仅加入了一个循环，用以遍历所以的训练样本并求出相应的梯度值。值得注意的是，我们在每个阶段都要重新打乱训练数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">    np.random.shuffle(data)</span><br><span class="line">    <span class="keyword">for</span> example <span class="keyword">in</span> data:</span><br><span class="line">        params_grad = evaluate_gradient(loss_function, example, params)</span><br><span class="line">        params = params - lr * params_grad</span><br></pre></td></tr></table></figure><h4 id="mini-batch-gradient-descent-小批量梯度下降">Mini-batch gradient descent 小批量梯度下降</h4><p>小批量梯度下降具有以上两者的优点。在每次更新中，对<code>n</code>个样本构成的一批数据，计算损失函数，并对相应的参数求导： <span class="math display">\[\theta=\theta-\eta{\nabla_\theta}J(\theta;x^{(i:i+n)};y^{(i:i+n)})\]</span> 这种方法，1. 降低了参数更新的方差，使得收敛过程更加稳定；</p><pre><code>              2. ​  能够利用最新的深度学习程序库中高度优化的矩阵运算器，能够高效的求出每小批数据的梯度。通常一小批数据含有的样本数量在50至256之间，但对于不同的用途也会有所变化。例如，当你的显存不够时，就把`batch_size`调小。</code></pre><p>小批量梯度下降法，通常是我们训练神经网络的首选算法。同时，有时候我们也会使用<strong>随机梯度下降法</strong>，来称呼<strong>小批量梯度下降法</strong>。</p><p>在代码中，不再迭代每个示例，而是迭代大小为50的小批量样本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">    np.random.shuffle(data)</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> get_batches(data, batch_size=<span class="number">50</span>):</span><br><span class="line">        params_grad = evaluate_gradient(loss_function, batch, params) / batch_size</span><br><span class="line">        params = params - lr * params_grad</span><br></pre></td></tr></table></figure><h3 id="sgd的缺点">SGD的缺点</h3><p>然而，小批量梯度下降法并不能保证良好地收敛，仍然存在一些问题。</p><p>1.选择一个适当的学习率是一个难题太小的学习率会导致较慢的收敛速度，而太大的学习率则会阻碍收敛，并会引起损失函数在最小值处波动，甚至发散。 2. 学习率计划表(learning_rate_schedule)试图在训练过程中调整学习率，例如退火，即很具预先定义的计划表减少学习率，或当各时期之间的目标变换低于阈值时。但是，这些调度和阈值必须提前定义，因此无法适应数据集的特征。 3. 此外，我们对所有的参数都采用了相同的学习率。但如果我们的数据是稀疏的，同时特征有着不同的出现频率，那么我们不希望以相同的学习率来更新这些变量，我们希望对较少出现的特征有更大的学习率。 4. 会无数次的陷入最小值或<strong>鞍点</strong>。鞍点是在一个方向上斜率是正的、在一个方向上斜率是负的点。鞍点周围各个方向的梯度值都为0，所以<strong>SGD</strong>很难从这些鞍点中脱开。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;梯度下降法，是当今最流行的最优化（optimization）算法，亦是至今最常用的最优化神经网络的方法。与此同时，最新的深度学习程序库都包含了各种优化梯度下降的算法（可以参见如 Pytorch 程序库的说明文档）。但他们的算法则不被公开，都作为黑箱优化器被使用，这也就是为什么它们的优势和劣势往往难以被实际地解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词：&lt;/strong&gt;Deep Learning&lt;/p&gt;</summary>
    
    
    
    
    <category term="Deep Learning" scheme="https://www.fly97.cn/tags/Deep-Learning/"/>
    
  </entry>
  
</feed>
